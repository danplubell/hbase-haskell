{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Database.HBase.Internal.Thrift2.HBase_Types where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()


data TDeleteType = DELETE_COLUMN|DELETE_COLUMNS  deriving (Show,Eq, Typeable, Ord)
instance Enum TDeleteType where
  fromEnum t = case t of
    DELETE_COLUMN -> 0
    DELETE_COLUMNS -> 1
  toEnum t = case t of
    0 -> DELETE_COLUMN
    1 -> DELETE_COLUMNS
    _ -> throw ThriftException
instance Hashable TDeleteType where
  hashWithSalt salt = hashWithSalt salt . fromEnum
data TDurability = SKIP_WAL|ASYNC_WAL|SYNC_WAL|FSYNC_WAL  deriving (Show,Eq, Typeable, Ord)
instance Enum TDurability where
  fromEnum t = case t of
    SKIP_WAL -> 1
    ASYNC_WAL -> 2
    SYNC_WAL -> 3
    FSYNC_WAL -> 4
  toEnum t = case t of
    1 -> SKIP_WAL
    2 -> ASYNC_WAL
    3 -> SYNC_WAL
    4 -> FSYNC_WAL
    _ -> throw ThriftException
instance Hashable TDurability where
  hashWithSalt salt = hashWithSalt salt . fromEnum
data TTimeRange = TTimeRange{f_TTimeRange_minStamp :: Maybe Int64,f_TTimeRange_maxStamp :: Maybe Int64} deriving (Show,Eq,Typeable)
instance Hashable TTimeRange where
  hashWithSalt salt record = salt   `hashWithSalt` f_TTimeRange_minStamp record   `hashWithSalt` f_TTimeRange_maxStamp record  
write_TTimeRange oprot record = do
  writeStructBegin oprot "TTimeRange"
  case f_TTimeRange_minStamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("minStamp",T_I64,1)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_TTimeRange_maxStamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("maxStamp",T_I64,2)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TTimeRange_fields iprot record = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return record else
    case _id4 of 
      1 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_TTimeRange_fields iprot record{f_TTimeRange_minStamp=Just s}
        else do
          skip iprot _t3
          read_TTimeRange_fields iprot record
      2 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_TTimeRange_fields iprot record{f_TTimeRange_maxStamp=Just s}
        else do
          skip iprot _t3
          read_TTimeRange_fields iprot record
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_TTimeRange_fields iprot record
read_TTimeRange iprot = do
  _ <- readStructBegin iprot
  record <- read_TTimeRange_fields iprot (TTimeRange{f_TTimeRange_minStamp=Nothing,f_TTimeRange_maxStamp=Nothing})
  readStructEnd iprot
  return record
data TColumn = TColumn{f_TColumn_family :: Maybe ByteString,f_TColumn_qualifier :: Maybe ByteString,f_TColumn_timestamp :: Maybe Int64} deriving (Show,Eq,Typeable)
instance Hashable TColumn where
  hashWithSalt salt record = salt   `hashWithSalt` f_TColumn_family record   `hashWithSalt` f_TColumn_qualifier record   `hashWithSalt` f_TColumn_timestamp record  
write_TColumn oprot record = do
  writeStructBegin oprot "TColumn"
  case f_TColumn_family record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("family",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TColumn_qualifier record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("qualifier",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TColumn_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TColumn_fields iprot record = do
  (_,_t8,_id9) <- readFieldBegin iprot
  if _t8 == T_STOP then return record else
    case _id9 of 
      1 -> if _t8 == T_STRING then do
        s <- readBinary iprot
        read_TColumn_fields iprot record{f_TColumn_family=Just s}
        else do
          skip iprot _t8
          read_TColumn_fields iprot record
      2 -> if _t8 == T_STRING then do
        s <- readBinary iprot
        read_TColumn_fields iprot record{f_TColumn_qualifier=Just s}
        else do
          skip iprot _t8
          read_TColumn_fields iprot record
      3 -> if _t8 == T_I64 then do
        s <- readI64 iprot
        read_TColumn_fields iprot record{f_TColumn_timestamp=Just s}
        else do
          skip iprot _t8
          read_TColumn_fields iprot record
      _ -> do
        skip iprot _t8
        readFieldEnd iprot
        read_TColumn_fields iprot record
read_TColumn iprot = do
  _ <- readStructBegin iprot
  record <- read_TColumn_fields iprot (TColumn{f_TColumn_family=Nothing,f_TColumn_qualifier=Nothing,f_TColumn_timestamp=Nothing})
  readStructEnd iprot
  return record
data TColumnValue = TColumnValue{f_TColumnValue_family :: Maybe ByteString,f_TColumnValue_qualifier :: Maybe ByteString,f_TColumnValue_value :: Maybe ByteString,f_TColumnValue_timestamp :: Maybe Int64} deriving (Show,Eq,Typeable)
instance Hashable TColumnValue where
  hashWithSalt salt record = salt   `hashWithSalt` f_TColumnValue_family record   `hashWithSalt` f_TColumnValue_qualifier record   `hashWithSalt` f_TColumnValue_value record   `hashWithSalt` f_TColumnValue_timestamp record  
write_TColumnValue oprot record = do
  writeStructBegin oprot "TColumnValue"
  case f_TColumnValue_family record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("family",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TColumnValue_qualifier record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("qualifier",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TColumnValue_value record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("value",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TColumnValue_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,4)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TColumnValue_fields iprot record = do
  (_,_t13,_id14) <- readFieldBegin iprot
  if _t13 == T_STOP then return record else
    case _id14 of 
      1 -> if _t13 == T_STRING then do
        s <- readBinary iprot
        read_TColumnValue_fields iprot record{f_TColumnValue_family=Just s}
        else do
          skip iprot _t13
          read_TColumnValue_fields iprot record
      2 -> if _t13 == T_STRING then do
        s <- readBinary iprot
        read_TColumnValue_fields iprot record{f_TColumnValue_qualifier=Just s}
        else do
          skip iprot _t13
          read_TColumnValue_fields iprot record
      3 -> if _t13 == T_STRING then do
        s <- readBinary iprot
        read_TColumnValue_fields iprot record{f_TColumnValue_value=Just s}
        else do
          skip iprot _t13
          read_TColumnValue_fields iprot record
      4 -> if _t13 == T_I64 then do
        s <- readI64 iprot
        read_TColumnValue_fields iprot record{f_TColumnValue_timestamp=Just s}
        else do
          skip iprot _t13
          read_TColumnValue_fields iprot record
      _ -> do
        skip iprot _t13
        readFieldEnd iprot
        read_TColumnValue_fields iprot record
read_TColumnValue iprot = do
  _ <- readStructBegin iprot
  record <- read_TColumnValue_fields iprot (TColumnValue{f_TColumnValue_family=Nothing,f_TColumnValue_qualifier=Nothing,f_TColumnValue_value=Nothing,f_TColumnValue_timestamp=Nothing})
  readStructEnd iprot
  return record
data TColumnIncrement = TColumnIncrement{f_TColumnIncrement_family :: Maybe ByteString,f_TColumnIncrement_qualifier :: Maybe ByteString,f_TColumnIncrement_amount :: Maybe Int64} deriving (Show,Eq,Typeable)
instance Hashable TColumnIncrement where
  hashWithSalt salt record = salt   `hashWithSalt` f_TColumnIncrement_family record   `hashWithSalt` f_TColumnIncrement_qualifier record   `hashWithSalt` f_TColumnIncrement_amount record  
write_TColumnIncrement oprot record = do
  writeStructBegin oprot "TColumnIncrement"
  case f_TColumnIncrement_family record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("family",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TColumnIncrement_qualifier record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("qualifier",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TColumnIncrement_amount record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("amount",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TColumnIncrement_fields iprot record = do
  (_,_t18,_id19) <- readFieldBegin iprot
  if _t18 == T_STOP then return record else
    case _id19 of 
      1 -> if _t18 == T_STRING then do
        s <- readBinary iprot
        read_TColumnIncrement_fields iprot record{f_TColumnIncrement_family=Just s}
        else do
          skip iprot _t18
          read_TColumnIncrement_fields iprot record
      2 -> if _t18 == T_STRING then do
        s <- readBinary iprot
        read_TColumnIncrement_fields iprot record{f_TColumnIncrement_qualifier=Just s}
        else do
          skip iprot _t18
          read_TColumnIncrement_fields iprot record
      3 -> if _t18 == T_I64 then do
        s <- readI64 iprot
        read_TColumnIncrement_fields iprot record{f_TColumnIncrement_amount=Just s}
        else do
          skip iprot _t18
          read_TColumnIncrement_fields iprot record
      _ -> do
        skip iprot _t18
        readFieldEnd iprot
        read_TColumnIncrement_fields iprot record
read_TColumnIncrement iprot = do
  _ <- readStructBegin iprot
  record <- read_TColumnIncrement_fields iprot (TColumnIncrement{f_TColumnIncrement_family=Nothing,f_TColumnIncrement_qualifier=Nothing,f_TColumnIncrement_amount=Nothing})
  readStructEnd iprot
  return record
data TResult = TResult{f_TResult_row :: Maybe ByteString,f_TResult_columnValues :: Maybe (Vector.Vector TColumnValue)} deriving (Show,Eq,Typeable)
instance Hashable TResult where
  hashWithSalt salt record = salt   `hashWithSalt` f_TResult_row record   `hashWithSalt` f_TResult_columnValues record  
write_TResult oprot record = do
  writeStructBegin oprot "TResult"
  case f_TResult_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TResult_columnValues record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columnValues",T_LIST,2)
    (let f = Vector.mapM_ (\_viter22 -> write_TColumnValue oprot _viter22) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TResult_fields iprot record = do
  (_,_t24,_id25) <- readFieldBegin iprot
  if _t24 == T_STOP then return record else
    case _id25 of 
      1 -> if _t24 == T_STRING then do
        s <- readBinary iprot
        read_TResult_fields iprot record{f_TResult_row=Just s}
        else do
          skip iprot _t24
          read_TResult_fields iprot record
      2 -> if _t24 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TColumnValue iprot)) in do {(_etype29,_size26) <- readListBegin iprot; f _size26})
        read_TResult_fields iprot record{f_TResult_columnValues=Just s}
        else do
          skip iprot _t24
          read_TResult_fields iprot record
      _ -> do
        skip iprot _t24
        readFieldEnd iprot
        read_TResult_fields iprot record
read_TResult iprot = do
  _ <- readStructBegin iprot
  record <- read_TResult_fields iprot (TResult{f_TResult_row=Nothing,f_TResult_columnValues=Nothing})
  readStructEnd iprot
  return record
data TGet = TGet{f_TGet_row :: Maybe ByteString,f_TGet_columns :: Maybe (Vector.Vector TColumn),f_TGet_timestamp :: Maybe Int64,f_TGet_timeRange :: Maybe TTimeRange,f_TGet_maxVersions :: Maybe Int32,f_TGet_filterString :: Maybe ByteString,f_TGet_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable TGet where
  hashWithSalt salt record = salt   `hashWithSalt` f_TGet_row record   `hashWithSalt` f_TGet_columns record   `hashWithSalt` f_TGet_timestamp record   `hashWithSalt` f_TGet_timeRange record   `hashWithSalt` f_TGet_maxVersions record   `hashWithSalt` f_TGet_filterString record   `hashWithSalt` f_TGet_attributes record  
write_TGet oprot record = do
  writeStructBegin oprot "TGet"
  case f_TGet_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TGet_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,2)
    (let f = Vector.mapM_ (\_viter33 -> write_TColumn oprot _viter33) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_TGet_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_TGet_timeRange record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timeRange",T_STRUCT,4)
    write_TTimeRange oprot _v
    writeFieldEnd oprot}
  case f_TGet_maxVersions record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("maxVersions",T_I32,5)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_TGet_filterString record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("filterString",T_STRING,6)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TGet_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,7)
    (let {f [] = return (); f ((_kiter34,_viter35):t) = do {do {writeBinary oprot _kiter34;writeBinary oprot _viter35};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TGet_fields iprot record = do
  (_,_t37,_id38) <- readFieldBegin iprot
  if _t37 == T_STOP then return record else
    case _id38 of 
      1 -> if _t37 == T_STRING then do
        s <- readBinary iprot
        read_TGet_fields iprot record{f_TGet_row=Just s}
        else do
          skip iprot _t37
          read_TGet_fields iprot record
      2 -> if _t37 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TColumn iprot)) in do {(_etype42,_size39) <- readListBegin iprot; f _size39})
        read_TGet_fields iprot record{f_TGet_columns=Just s}
        else do
          skip iprot _t37
          read_TGet_fields iprot record
      3 -> if _t37 == T_I64 then do
        s <- readI64 iprot
        read_TGet_fields iprot record{f_TGet_timestamp=Just s}
        else do
          skip iprot _t37
          read_TGet_fields iprot record
      4 -> if _t37 == T_STRUCT then do
        s <- (read_TTimeRange iprot)
        read_TGet_fields iprot record{f_TGet_timeRange=Just s}
        else do
          skip iprot _t37
          read_TGet_fields iprot record
      5 -> if _t37 == T_I32 then do
        s <- readI32 iprot
        read_TGet_fields iprot record{f_TGet_maxVersions=Just s}
        else do
          skip iprot _t37
          read_TGet_fields iprot record
      6 -> if _t37 == T_STRING then do
        s <- readBinary iprot
        read_TGet_fields iprot record{f_TGet_filterString=Just s}
        else do
          skip iprot _t37
          read_TGet_fields iprot record
      7 -> if _t37 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype45,_vtype46,_size44) <- readMapBegin iprot; l <- f _size44; return $ Map.fromList l})
        read_TGet_fields iprot record{f_TGet_attributes=Just s}
        else do
          skip iprot _t37
          read_TGet_fields iprot record
      _ -> do
        skip iprot _t37
        readFieldEnd iprot
        read_TGet_fields iprot record
read_TGet iprot = do
  _ <- readStructBegin iprot
  record <- read_TGet_fields iprot (TGet{f_TGet_row=Nothing,f_TGet_columns=Nothing,f_TGet_timestamp=Nothing,f_TGet_timeRange=Nothing,f_TGet_maxVersions=Nothing,f_TGet_filterString=Nothing,f_TGet_attributes=Nothing})
  readStructEnd iprot
  return record
data TPut = TPut{f_TPut_row :: Maybe ByteString,f_TPut_columnValues :: Maybe (Vector.Vector TColumnValue),f_TPut_timestamp :: Maybe Int64,f_TPut_attributes :: Maybe (Map.HashMap ByteString ByteString),f_TPut_durability :: Maybe TDurability} deriving (Show,Eq,Typeable)
instance Hashable TPut where
  hashWithSalt salt record = salt   `hashWithSalt` f_TPut_row record   `hashWithSalt` f_TPut_columnValues record   `hashWithSalt` f_TPut_timestamp record   `hashWithSalt` f_TPut_attributes record   `hashWithSalt` f_TPut_durability record  
write_TPut oprot record = do
  writeStructBegin oprot "TPut"
  case f_TPut_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TPut_columnValues record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columnValues",T_LIST,2)
    (let f = Vector.mapM_ (\_viter51 -> write_TColumnValue oprot _viter51) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_TPut_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_TPut_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,5)
    (let {f [] = return (); f ((_kiter52,_viter53):t) = do {do {writeBinary oprot _kiter52;writeBinary oprot _viter53};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  case f_TPut_durability record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("durability",T_I32,6)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TPut_fields iprot record = do
  (_,_t55,_id56) <- readFieldBegin iprot
  if _t55 == T_STOP then return record else
    case _id56 of 
      1 -> if _t55 == T_STRING then do
        s <- readBinary iprot
        read_TPut_fields iprot record{f_TPut_row=Just s}
        else do
          skip iprot _t55
          read_TPut_fields iprot record
      2 -> if _t55 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TColumnValue iprot)) in do {(_etype60,_size57) <- readListBegin iprot; f _size57})
        read_TPut_fields iprot record{f_TPut_columnValues=Just s}
        else do
          skip iprot _t55
          read_TPut_fields iprot record
      3 -> if _t55 == T_I64 then do
        s <- readI64 iprot
        read_TPut_fields iprot record{f_TPut_timestamp=Just s}
        else do
          skip iprot _t55
          read_TPut_fields iprot record
      5 -> if _t55 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype63,_vtype64,_size62) <- readMapBegin iprot; l <- f _size62; return $ Map.fromList l})
        read_TPut_fields iprot record{f_TPut_attributes=Just s}
        else do
          skip iprot _t55
          read_TPut_fields iprot record
      6 -> if _t55 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_TPut_fields iprot record{f_TPut_durability=Just s}
        else do
          skip iprot _t55
          read_TPut_fields iprot record
      _ -> do
        skip iprot _t55
        readFieldEnd iprot
        read_TPut_fields iprot record
read_TPut iprot = do
  _ <- readStructBegin iprot
  record <- read_TPut_fields iprot (TPut{f_TPut_row=Nothing,f_TPut_columnValues=Nothing,f_TPut_timestamp=Nothing,f_TPut_attributes=Nothing,f_TPut_durability=Nothing})
  readStructEnd iprot
  return record
data TDelete = TDelete{f_TDelete_row :: Maybe ByteString,f_TDelete_columns :: Maybe (Vector.Vector TColumn),f_TDelete_timestamp :: Maybe Int64,f_TDelete_deleteType :: Maybe TDeleteType,f_TDelete_attributes :: Maybe (Map.HashMap ByteString ByteString),f_TDelete_durability :: Maybe TDurability} deriving (Show,Eq,Typeable)
instance Hashable TDelete where
  hashWithSalt salt record = salt   `hashWithSalt` f_TDelete_row record   `hashWithSalt` f_TDelete_columns record   `hashWithSalt` f_TDelete_timestamp record   `hashWithSalt` f_TDelete_deleteType record   `hashWithSalt` f_TDelete_attributes record   `hashWithSalt` f_TDelete_durability record  
write_TDelete oprot record = do
  writeStructBegin oprot "TDelete"
  case f_TDelete_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TDelete_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,2)
    (let f = Vector.mapM_ (\_viter69 -> write_TColumn oprot _viter69) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_TDelete_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_TDelete_deleteType record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("deleteType",T_I32,4)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_TDelete_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,6)
    (let {f [] = return (); f ((_kiter70,_viter71):t) = do {do {writeBinary oprot _kiter70;writeBinary oprot _viter71};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  case f_TDelete_durability record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("durability",T_I32,7)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TDelete_fields iprot record = do
  (_,_t73,_id74) <- readFieldBegin iprot
  if _t73 == T_STOP then return record else
    case _id74 of 
      1 -> if _t73 == T_STRING then do
        s <- readBinary iprot
        read_TDelete_fields iprot record{f_TDelete_row=Just s}
        else do
          skip iprot _t73
          read_TDelete_fields iprot record
      2 -> if _t73 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TColumn iprot)) in do {(_etype78,_size75) <- readListBegin iprot; f _size75})
        read_TDelete_fields iprot record{f_TDelete_columns=Just s}
        else do
          skip iprot _t73
          read_TDelete_fields iprot record
      3 -> if _t73 == T_I64 then do
        s <- readI64 iprot
        read_TDelete_fields iprot record{f_TDelete_timestamp=Just s}
        else do
          skip iprot _t73
          read_TDelete_fields iprot record
      4 -> if _t73 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_TDelete_fields iprot record{f_TDelete_deleteType=Just s}
        else do
          skip iprot _t73
          read_TDelete_fields iprot record
      6 -> if _t73 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype81,_vtype82,_size80) <- readMapBegin iprot; l <- f _size80; return $ Map.fromList l})
        read_TDelete_fields iprot record{f_TDelete_attributes=Just s}
        else do
          skip iprot _t73
          read_TDelete_fields iprot record
      7 -> if _t73 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_TDelete_fields iprot record{f_TDelete_durability=Just s}
        else do
          skip iprot _t73
          read_TDelete_fields iprot record
      _ -> do
        skip iprot _t73
        readFieldEnd iprot
        read_TDelete_fields iprot record
read_TDelete iprot = do
  _ <- readStructBegin iprot
  record <- read_TDelete_fields iprot (TDelete{f_TDelete_row=Nothing,f_TDelete_columns=Nothing,f_TDelete_timestamp=Nothing,f_TDelete_deleteType=Nothing,f_TDelete_attributes=Nothing,f_TDelete_durability=Nothing})
  readStructEnd iprot
  return record
data TIncrement = TIncrement{f_TIncrement_row :: Maybe ByteString,f_TIncrement_columns :: Maybe (Vector.Vector TColumnIncrement),f_TIncrement_attributes :: Maybe (Map.HashMap ByteString ByteString),f_TIncrement_durability :: Maybe TDurability} deriving (Show,Eq,Typeable)
instance Hashable TIncrement where
  hashWithSalt salt record = salt   `hashWithSalt` f_TIncrement_row record   `hashWithSalt` f_TIncrement_columns record   `hashWithSalt` f_TIncrement_attributes record   `hashWithSalt` f_TIncrement_durability record  
write_TIncrement oprot record = do
  writeStructBegin oprot "TIncrement"
  case f_TIncrement_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TIncrement_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,2)
    (let f = Vector.mapM_ (\_viter87 -> write_TColumnIncrement oprot _viter87) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_TIncrement_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter88,_viter89):t) = do {do {writeBinary oprot _kiter88;writeBinary oprot _viter89};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  case f_TIncrement_durability record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("durability",T_I32,5)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TIncrement_fields iprot record = do
  (_,_t91,_id92) <- readFieldBegin iprot
  if _t91 == T_STOP then return record else
    case _id92 of 
      1 -> if _t91 == T_STRING then do
        s <- readBinary iprot
        read_TIncrement_fields iprot record{f_TIncrement_row=Just s}
        else do
          skip iprot _t91
          read_TIncrement_fields iprot record
      2 -> if _t91 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TColumnIncrement iprot)) in do {(_etype96,_size93) <- readListBegin iprot; f _size93})
        read_TIncrement_fields iprot record{f_TIncrement_columns=Just s}
        else do
          skip iprot _t91
          read_TIncrement_fields iprot record
      4 -> if _t91 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype99,_vtype100,_size98) <- readMapBegin iprot; l <- f _size98; return $ Map.fromList l})
        read_TIncrement_fields iprot record{f_TIncrement_attributes=Just s}
        else do
          skip iprot _t91
          read_TIncrement_fields iprot record
      5 -> if _t91 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_TIncrement_fields iprot record{f_TIncrement_durability=Just s}
        else do
          skip iprot _t91
          read_TIncrement_fields iprot record
      _ -> do
        skip iprot _t91
        readFieldEnd iprot
        read_TIncrement_fields iprot record
read_TIncrement iprot = do
  _ <- readStructBegin iprot
  record <- read_TIncrement_fields iprot (TIncrement{f_TIncrement_row=Nothing,f_TIncrement_columns=Nothing,f_TIncrement_attributes=Nothing,f_TIncrement_durability=Nothing})
  readStructEnd iprot
  return record
data TScan = TScan{f_TScan_startRow :: Maybe ByteString,f_TScan_stopRow :: Maybe ByteString,f_TScan_columns :: Maybe (Vector.Vector TColumn),f_TScan_caching :: Maybe Int32,f_TScan_maxVersions :: Maybe Int32,f_TScan_timeRange :: Maybe TTimeRange,f_TScan_filterString :: Maybe ByteString,f_TScan_batchSize :: Maybe Int32,f_TScan_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable TScan where
  hashWithSalt salt record = salt   `hashWithSalt` f_TScan_startRow record   `hashWithSalt` f_TScan_stopRow record   `hashWithSalt` f_TScan_columns record   `hashWithSalt` f_TScan_caching record   `hashWithSalt` f_TScan_maxVersions record   `hashWithSalt` f_TScan_timeRange record   `hashWithSalt` f_TScan_filterString record   `hashWithSalt` f_TScan_batchSize record   `hashWithSalt` f_TScan_attributes record  
write_TScan oprot record = do
  writeStructBegin oprot "TScan"
  case f_TScan_startRow record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("startRow",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TScan_stopRow record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("stopRow",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TScan_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,3)
    (let f = Vector.mapM_ (\_viter105 -> write_TColumn oprot _viter105) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_TScan_caching record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("caching",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_TScan_maxVersions record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("maxVersions",T_I32,5)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_TScan_timeRange record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timeRange",T_STRUCT,6)
    write_TTimeRange oprot _v
    writeFieldEnd oprot}
  case f_TScan_filterString record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("filterString",T_STRING,7)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TScan_batchSize record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("batchSize",T_I32,8)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_TScan_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,9)
    (let {f [] = return (); f ((_kiter106,_viter107):t) = do {do {writeBinary oprot _kiter106;writeBinary oprot _viter107};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TScan_fields iprot record = do
  (_,_t109,_id110) <- readFieldBegin iprot
  if _t109 == T_STOP then return record else
    case _id110 of 
      1 -> if _t109 == T_STRING then do
        s <- readBinary iprot
        read_TScan_fields iprot record{f_TScan_startRow=Just s}
        else do
          skip iprot _t109
          read_TScan_fields iprot record
      2 -> if _t109 == T_STRING then do
        s <- readBinary iprot
        read_TScan_fields iprot record{f_TScan_stopRow=Just s}
        else do
          skip iprot _t109
          read_TScan_fields iprot record
      3 -> if _t109 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TColumn iprot)) in do {(_etype114,_size111) <- readListBegin iprot; f _size111})
        read_TScan_fields iprot record{f_TScan_columns=Just s}
        else do
          skip iprot _t109
          read_TScan_fields iprot record
      4 -> if _t109 == T_I32 then do
        s <- readI32 iprot
        read_TScan_fields iprot record{f_TScan_caching=Just s}
        else do
          skip iprot _t109
          read_TScan_fields iprot record
      5 -> if _t109 == T_I32 then do
        s <- readI32 iprot
        read_TScan_fields iprot record{f_TScan_maxVersions=Just s}
        else do
          skip iprot _t109
          read_TScan_fields iprot record
      6 -> if _t109 == T_STRUCT then do
        s <- (read_TTimeRange iprot)
        read_TScan_fields iprot record{f_TScan_timeRange=Just s}
        else do
          skip iprot _t109
          read_TScan_fields iprot record
      7 -> if _t109 == T_STRING then do
        s <- readBinary iprot
        read_TScan_fields iprot record{f_TScan_filterString=Just s}
        else do
          skip iprot _t109
          read_TScan_fields iprot record
      8 -> if _t109 == T_I32 then do
        s <- readI32 iprot
        read_TScan_fields iprot record{f_TScan_batchSize=Just s}
        else do
          skip iprot _t109
          read_TScan_fields iprot record
      9 -> if _t109 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype117,_vtype118,_size116) <- readMapBegin iprot; l <- f _size116; return $ Map.fromList l})
        read_TScan_fields iprot record{f_TScan_attributes=Just s}
        else do
          skip iprot _t109
          read_TScan_fields iprot record
      _ -> do
        skip iprot _t109
        readFieldEnd iprot
        read_TScan_fields iprot record
read_TScan iprot = do
  _ <- readStructBegin iprot
  record <- read_TScan_fields iprot (TScan{f_TScan_startRow=Nothing,f_TScan_stopRow=Nothing,f_TScan_columns=Nothing,f_TScan_caching=Nothing,f_TScan_maxVersions=Nothing,f_TScan_timeRange=Nothing,f_TScan_filterString=Nothing,f_TScan_batchSize=Nothing,f_TScan_attributes=Nothing})
  readStructEnd iprot
  return record
data TMutation = TMutation{f_TMutation_put :: Maybe TPut,f_TMutation_deleteSingle :: Maybe TDelete} deriving (Show,Eq,Typeable)
instance Hashable TMutation where
  hashWithSalt salt record = salt   `hashWithSalt` f_TMutation_put record   `hashWithSalt` f_TMutation_deleteSingle record  
write_TMutation oprot record = do
  writeStructBegin oprot "TMutation"
  case f_TMutation_put record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("put",T_STRUCT,1)
    write_TPut oprot _v
    writeFieldEnd oprot}
  case f_TMutation_deleteSingle record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("deleteSingle",T_STRUCT,2)
    write_TDelete oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TMutation_fields iprot record = do
  (_,_t124,_id125) <- readFieldBegin iprot
  if _t124 == T_STOP then return record else
    case _id125 of 
      1 -> if _t124 == T_STRUCT then do
        s <- (read_TPut iprot)
        read_TMutation_fields iprot record{f_TMutation_put=Just s}
        else do
          skip iprot _t124
          read_TMutation_fields iprot record
      2 -> if _t124 == T_STRUCT then do
        s <- (read_TDelete iprot)
        read_TMutation_fields iprot record{f_TMutation_deleteSingle=Just s}
        else do
          skip iprot _t124
          read_TMutation_fields iprot record
      _ -> do
        skip iprot _t124
        readFieldEnd iprot
        read_TMutation_fields iprot record
read_TMutation iprot = do
  _ <- readStructBegin iprot
  record <- read_TMutation_fields iprot (TMutation{f_TMutation_put=Nothing,f_TMutation_deleteSingle=Nothing})
  readStructEnd iprot
  return record
data TRowMutations = TRowMutations{f_TRowMutations_row :: Maybe ByteString,f_TRowMutations_mutations :: Maybe (Vector.Vector TMutation)} deriving (Show,Eq,Typeable)
instance Hashable TRowMutations where
  hashWithSalt salt record = salt   `hashWithSalt` f_TRowMutations_row record   `hashWithSalt` f_TRowMutations_mutations record  
write_TRowMutations oprot record = do
  writeStructBegin oprot "TRowMutations"
  case f_TRowMutations_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_TRowMutations_mutations record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("mutations",T_LIST,2)
    (let f = Vector.mapM_ (\_viter128 -> write_TMutation oprot _viter128) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TRowMutations_fields iprot record = do
  (_,_t130,_id131) <- readFieldBegin iprot
  if _t130 == T_STOP then return record else
    case _id131 of 
      1 -> if _t130 == T_STRING then do
        s <- readBinary iprot
        read_TRowMutations_fields iprot record{f_TRowMutations_row=Just s}
        else do
          skip iprot _t130
          read_TRowMutations_fields iprot record
      2 -> if _t130 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TMutation iprot)) in do {(_etype135,_size132) <- readListBegin iprot; f _size132})
        read_TRowMutations_fields iprot record{f_TRowMutations_mutations=Just s}
        else do
          skip iprot _t130
          read_TRowMutations_fields iprot record
      _ -> do
        skip iprot _t130
        readFieldEnd iprot
        read_TRowMutations_fields iprot record
read_TRowMutations iprot = do
  _ <- readStructBegin iprot
  record <- read_TRowMutations_fields iprot (TRowMutations{f_TRowMutations_row=Nothing,f_TRowMutations_mutations=Nothing})
  readStructEnd iprot
  return record
data TIOError = TIOError{f_TIOError_message :: Maybe Text} deriving (Show,Eq,Typeable)
instance Exception TIOError
instance Hashable TIOError where
  hashWithSalt salt record = salt   `hashWithSalt` f_TIOError_message record  
write_TIOError oprot record = do
  writeStructBegin oprot "TIOError"
  case f_TIOError_message record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("message",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TIOError_fields iprot record = do
  (_,_t140,_id141) <- readFieldBegin iprot
  if _t140 == T_STOP then return record else
    case _id141 of 
      1 -> if _t140 == T_STRING then do
        s <- readString iprot
        read_TIOError_fields iprot record{f_TIOError_message=Just s}
        else do
          skip iprot _t140
          read_TIOError_fields iprot record
      _ -> do
        skip iprot _t140
        readFieldEnd iprot
        read_TIOError_fields iprot record
read_TIOError iprot = do
  _ <- readStructBegin iprot
  record <- read_TIOError_fields iprot (TIOError{f_TIOError_message=Nothing})
  readStructEnd iprot
  return record
data TIllegalArgument = TIllegalArgument{f_TIllegalArgument_message :: Maybe Text} deriving (Show,Eq,Typeable)
instance Exception TIllegalArgument
instance Hashable TIllegalArgument where
  hashWithSalt salt record = salt   `hashWithSalt` f_TIllegalArgument_message record  
write_TIllegalArgument oprot record = do
  writeStructBegin oprot "TIllegalArgument"
  case f_TIllegalArgument_message record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("message",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_TIllegalArgument_fields iprot record = do
  (_,_t145,_id146) <- readFieldBegin iprot
  if _t145 == T_STOP then return record else
    case _id146 of 
      1 -> if _t145 == T_STRING then do
        s <- readString iprot
        read_TIllegalArgument_fields iprot record{f_TIllegalArgument_message=Just s}
        else do
          skip iprot _t145
          read_TIllegalArgument_fields iprot record
      _ -> do
        skip iprot _t145
        readFieldEnd iprot
        read_TIllegalArgument_fields iprot record
read_TIllegalArgument iprot = do
  _ <- readStructBegin iprot
  record <- read_TIllegalArgument_fields iprot (TIllegalArgument{f_TIllegalArgument_message=Nothing})
  readStructEnd iprot
  return record
