{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Database.HBase.Internal.Thrift2.THBaseService where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()


import Database.HBase.Internal.Thrift2.HBase_Types
import qualified Database.HBase.Internal.Thrift2.THBaseService_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Exists_args = Exists_args{f_Exists_args_table :: Maybe ByteString,f_Exists_args_get :: Maybe TGet} deriving (Show,Eq,Typeable)
instance Hashable Exists_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Exists_args_table record   `hashWithSalt` f_Exists_args_get record  
write_Exists_args oprot record = do
  writeStructBegin oprot "Exists_args"
  case f_Exists_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Exists_args_get record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("get",T_STRUCT,2)
    write_TGet oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Exists_args_fields iprot record = do
  (_,_t150,_id151) <- readFieldBegin iprot
  if _t150 == T_STOP then return record else
    case _id151 of 
      1 -> if _t150 == T_STRING then do
        s <- readBinary iprot
        read_Exists_args_fields iprot record{f_Exists_args_table=Just s}
        else do
          skip iprot _t150
          read_Exists_args_fields iprot record
      2 -> if _t150 == T_STRUCT then do
        s <- (read_TGet iprot)
        read_Exists_args_fields iprot record{f_Exists_args_get=Just s}
        else do
          skip iprot _t150
          read_Exists_args_fields iprot record
      _ -> do
        skip iprot _t150
        readFieldEnd iprot
        read_Exists_args_fields iprot record
read_Exists_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Exists_args_fields iprot (Exists_args{f_Exists_args_table=Nothing,f_Exists_args_get=Nothing})
  readStructEnd iprot
  return record
data Exists_result = Exists_result{f_Exists_result_success :: Maybe Bool,f_Exists_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable Exists_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Exists_result_success record   `hashWithSalt` f_Exists_result_io record  
write_Exists_result oprot record = do
  writeStructBegin oprot "Exists_result"
  case f_Exists_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_BOOL,0)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_Exists_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Exists_result_fields iprot record = do
  (_,_t155,_id156) <- readFieldBegin iprot
  if _t155 == T_STOP then return record else
    case _id156 of 
      0 -> if _t155 == T_BOOL then do
        s <- readBool iprot
        read_Exists_result_fields iprot record{f_Exists_result_success=Just s}
        else do
          skip iprot _t155
          read_Exists_result_fields iprot record
      1 -> if _t155 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_Exists_result_fields iprot record{f_Exists_result_io=Just s}
        else do
          skip iprot _t155
          read_Exists_result_fields iprot record
      _ -> do
        skip iprot _t155
        readFieldEnd iprot
        read_Exists_result_fields iprot record
read_Exists_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Exists_result_fields iprot (Exists_result{f_Exists_result_success=Nothing,f_Exists_result_io=Nothing})
  readStructEnd iprot
  return record
data Get_args = Get_args{f_Get_args_table :: Maybe ByteString,f_Get_args_get :: Maybe TGet} deriving (Show,Eq,Typeable)
instance Hashable Get_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Get_args_table record   `hashWithSalt` f_Get_args_get record  
write_Get_args oprot record = do
  writeStructBegin oprot "Get_args"
  case f_Get_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Get_args_get record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("get",T_STRUCT,2)
    write_TGet oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Get_args_fields iprot record = do
  (_,_t160,_id161) <- readFieldBegin iprot
  if _t160 == T_STOP then return record else
    case _id161 of 
      1 -> if _t160 == T_STRING then do
        s <- readBinary iprot
        read_Get_args_fields iprot record{f_Get_args_table=Just s}
        else do
          skip iprot _t160
          read_Get_args_fields iprot record
      2 -> if _t160 == T_STRUCT then do
        s <- (read_TGet iprot)
        read_Get_args_fields iprot record{f_Get_args_get=Just s}
        else do
          skip iprot _t160
          read_Get_args_fields iprot record
      _ -> do
        skip iprot _t160
        readFieldEnd iprot
        read_Get_args_fields iprot record
read_Get_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Get_args_fields iprot (Get_args{f_Get_args_table=Nothing,f_Get_args_get=Nothing})
  readStructEnd iprot
  return record
data Get_result = Get_result{f_Get_result_success :: Maybe TResult,f_Get_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable Get_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Get_result_success record   `hashWithSalt` f_Get_result_io record  
write_Get_result oprot record = do
  writeStructBegin oprot "Get_result"
  case f_Get_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    write_TResult oprot _v
    writeFieldEnd oprot}
  case f_Get_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Get_result_fields iprot record = do
  (_,_t165,_id166) <- readFieldBegin iprot
  if _t165 == T_STOP then return record else
    case _id166 of 
      0 -> if _t165 == T_STRUCT then do
        s <- (read_TResult iprot)
        read_Get_result_fields iprot record{f_Get_result_success=Just s}
        else do
          skip iprot _t165
          read_Get_result_fields iprot record
      1 -> if _t165 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_Get_result_fields iprot record{f_Get_result_io=Just s}
        else do
          skip iprot _t165
          read_Get_result_fields iprot record
      _ -> do
        skip iprot _t165
        readFieldEnd iprot
        read_Get_result_fields iprot record
read_Get_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Get_result_fields iprot (Get_result{f_Get_result_success=Nothing,f_Get_result_io=Nothing})
  readStructEnd iprot
  return record
data GetMultiple_args = GetMultiple_args{f_GetMultiple_args_table :: Maybe ByteString,f_GetMultiple_args_gets :: Maybe (Vector.Vector TGet)} deriving (Show,Eq,Typeable)
instance Hashable GetMultiple_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetMultiple_args_table record   `hashWithSalt` f_GetMultiple_args_gets record  
write_GetMultiple_args oprot record = do
  writeStructBegin oprot "GetMultiple_args"
  case f_GetMultiple_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetMultiple_args_gets record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("gets",T_LIST,2)
    (let f = Vector.mapM_ (\_viter169 -> write_TGet oprot _viter169) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetMultiple_args_fields iprot record = do
  (_,_t171,_id172) <- readFieldBegin iprot
  if _t171 == T_STOP then return record else
    case _id172 of 
      1 -> if _t171 == T_STRING then do
        s <- readBinary iprot
        read_GetMultiple_args_fields iprot record{f_GetMultiple_args_table=Just s}
        else do
          skip iprot _t171
          read_GetMultiple_args_fields iprot record
      2 -> if _t171 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TGet iprot)) in do {(_etype176,_size173) <- readListBegin iprot; f _size173})
        read_GetMultiple_args_fields iprot record{f_GetMultiple_args_gets=Just s}
        else do
          skip iprot _t171
          read_GetMultiple_args_fields iprot record
      _ -> do
        skip iprot _t171
        readFieldEnd iprot
        read_GetMultiple_args_fields iprot record
read_GetMultiple_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetMultiple_args_fields iprot (GetMultiple_args{f_GetMultiple_args_table=Nothing,f_GetMultiple_args_gets=Nothing})
  readStructEnd iprot
  return record
data GetMultiple_result = GetMultiple_result{f_GetMultiple_result_success :: Maybe (Vector.Vector TResult),f_GetMultiple_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable GetMultiple_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetMultiple_result_success record   `hashWithSalt` f_GetMultiple_result_io record  
write_GetMultiple_result oprot record = do
  writeStructBegin oprot "GetMultiple_result"
  case f_GetMultiple_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter180 -> write_TResult oprot _viter180) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetMultiple_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetMultiple_result_fields iprot record = do
  (_,_t182,_id183) <- readFieldBegin iprot
  if _t182 == T_STOP then return record else
    case _id183 of 
      0 -> if _t182 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TResult iprot)) in do {(_etype187,_size184) <- readListBegin iprot; f _size184})
        read_GetMultiple_result_fields iprot record{f_GetMultiple_result_success=Just s}
        else do
          skip iprot _t182
          read_GetMultiple_result_fields iprot record
      1 -> if _t182 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_GetMultiple_result_fields iprot record{f_GetMultiple_result_io=Just s}
        else do
          skip iprot _t182
          read_GetMultiple_result_fields iprot record
      _ -> do
        skip iprot _t182
        readFieldEnd iprot
        read_GetMultiple_result_fields iprot record
read_GetMultiple_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetMultiple_result_fields iprot (GetMultiple_result{f_GetMultiple_result_success=Nothing,f_GetMultiple_result_io=Nothing})
  readStructEnd iprot
  return record
data Put_args = Put_args{f_Put_args_table :: Maybe ByteString,f_Put_args_put :: Maybe TPut} deriving (Show,Eq,Typeable)
instance Hashable Put_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Put_args_table record   `hashWithSalt` f_Put_args_put record  
write_Put_args oprot record = do
  writeStructBegin oprot "Put_args"
  case f_Put_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Put_args_put record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("put",T_STRUCT,2)
    write_TPut oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Put_args_fields iprot record = do
  (_,_t192,_id193) <- readFieldBegin iprot
  if _t192 == T_STOP then return record else
    case _id193 of 
      1 -> if _t192 == T_STRING then do
        s <- readBinary iprot
        read_Put_args_fields iprot record{f_Put_args_table=Just s}
        else do
          skip iprot _t192
          read_Put_args_fields iprot record
      2 -> if _t192 == T_STRUCT then do
        s <- (read_TPut iprot)
        read_Put_args_fields iprot record{f_Put_args_put=Just s}
        else do
          skip iprot _t192
          read_Put_args_fields iprot record
      _ -> do
        skip iprot _t192
        readFieldEnd iprot
        read_Put_args_fields iprot record
read_Put_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Put_args_fields iprot (Put_args{f_Put_args_table=Nothing,f_Put_args_put=Nothing})
  readStructEnd iprot
  return record
data Put_result = Put_result{f_Put_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable Put_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Put_result_io record  
write_Put_result oprot record = do
  writeStructBegin oprot "Put_result"
  case f_Put_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Put_result_fields iprot record = do
  (_,_t197,_id198) <- readFieldBegin iprot
  if _t197 == T_STOP then return record else
    case _id198 of 
      1 -> if _t197 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_Put_result_fields iprot record{f_Put_result_io=Just s}
        else do
          skip iprot _t197
          read_Put_result_fields iprot record
      _ -> do
        skip iprot _t197
        readFieldEnd iprot
        read_Put_result_fields iprot record
read_Put_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Put_result_fields iprot (Put_result{f_Put_result_io=Nothing})
  readStructEnd iprot
  return record
data CheckAndPut_args = CheckAndPut_args{f_CheckAndPut_args_table :: Maybe ByteString,f_CheckAndPut_args_row :: Maybe ByteString,f_CheckAndPut_args_family :: Maybe ByteString,f_CheckAndPut_args_qualifier :: Maybe ByteString,f_CheckAndPut_args_value :: Maybe ByteString,f_CheckAndPut_args_put :: Maybe TPut} deriving (Show,Eq,Typeable)
instance Hashable CheckAndPut_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CheckAndPut_args_table record   `hashWithSalt` f_CheckAndPut_args_row record   `hashWithSalt` f_CheckAndPut_args_family record   `hashWithSalt` f_CheckAndPut_args_qualifier record   `hashWithSalt` f_CheckAndPut_args_value record   `hashWithSalt` f_CheckAndPut_args_put record  
write_CheckAndPut_args oprot record = do
  writeStructBegin oprot "CheckAndPut_args"
  case f_CheckAndPut_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CheckAndPut_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CheckAndPut_args_family record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("family",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CheckAndPut_args_qualifier record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("qualifier",T_STRING,4)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CheckAndPut_args_value record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("value",T_STRING,5)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CheckAndPut_args_put record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("put",T_STRUCT,6)
    write_TPut oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CheckAndPut_args_fields iprot record = do
  (_,_t202,_id203) <- readFieldBegin iprot
  if _t202 == T_STOP then return record else
    case _id203 of 
      1 -> if _t202 == T_STRING then do
        s <- readBinary iprot
        read_CheckAndPut_args_fields iprot record{f_CheckAndPut_args_table=Just s}
        else do
          skip iprot _t202
          read_CheckAndPut_args_fields iprot record
      2 -> if _t202 == T_STRING then do
        s <- readBinary iprot
        read_CheckAndPut_args_fields iprot record{f_CheckAndPut_args_row=Just s}
        else do
          skip iprot _t202
          read_CheckAndPut_args_fields iprot record
      3 -> if _t202 == T_STRING then do
        s <- readBinary iprot
        read_CheckAndPut_args_fields iprot record{f_CheckAndPut_args_family=Just s}
        else do
          skip iprot _t202
          read_CheckAndPut_args_fields iprot record
      4 -> if _t202 == T_STRING then do
        s <- readBinary iprot
        read_CheckAndPut_args_fields iprot record{f_CheckAndPut_args_qualifier=Just s}
        else do
          skip iprot _t202
          read_CheckAndPut_args_fields iprot record
      5 -> if _t202 == T_STRING then do
        s <- readBinary iprot
        read_CheckAndPut_args_fields iprot record{f_CheckAndPut_args_value=Just s}
        else do
          skip iprot _t202
          read_CheckAndPut_args_fields iprot record
      6 -> if _t202 == T_STRUCT then do
        s <- (read_TPut iprot)
        read_CheckAndPut_args_fields iprot record{f_CheckAndPut_args_put=Just s}
        else do
          skip iprot _t202
          read_CheckAndPut_args_fields iprot record
      _ -> do
        skip iprot _t202
        readFieldEnd iprot
        read_CheckAndPut_args_fields iprot record
read_CheckAndPut_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CheckAndPut_args_fields iprot (CheckAndPut_args{f_CheckAndPut_args_table=Nothing,f_CheckAndPut_args_row=Nothing,f_CheckAndPut_args_family=Nothing,f_CheckAndPut_args_qualifier=Nothing,f_CheckAndPut_args_value=Nothing,f_CheckAndPut_args_put=Nothing})
  readStructEnd iprot
  return record
data CheckAndPut_result = CheckAndPut_result{f_CheckAndPut_result_success :: Maybe Bool,f_CheckAndPut_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable CheckAndPut_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CheckAndPut_result_success record   `hashWithSalt` f_CheckAndPut_result_io record  
write_CheckAndPut_result oprot record = do
  writeStructBegin oprot "CheckAndPut_result"
  case f_CheckAndPut_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_BOOL,0)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_CheckAndPut_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CheckAndPut_result_fields iprot record = do
  (_,_t207,_id208) <- readFieldBegin iprot
  if _t207 == T_STOP then return record else
    case _id208 of 
      0 -> if _t207 == T_BOOL then do
        s <- readBool iprot
        read_CheckAndPut_result_fields iprot record{f_CheckAndPut_result_success=Just s}
        else do
          skip iprot _t207
          read_CheckAndPut_result_fields iprot record
      1 -> if _t207 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_CheckAndPut_result_fields iprot record{f_CheckAndPut_result_io=Just s}
        else do
          skip iprot _t207
          read_CheckAndPut_result_fields iprot record
      _ -> do
        skip iprot _t207
        readFieldEnd iprot
        read_CheckAndPut_result_fields iprot record
read_CheckAndPut_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CheckAndPut_result_fields iprot (CheckAndPut_result{f_CheckAndPut_result_success=Nothing,f_CheckAndPut_result_io=Nothing})
  readStructEnd iprot
  return record
data PutMultiple_args = PutMultiple_args{f_PutMultiple_args_table :: Maybe ByteString,f_PutMultiple_args_puts :: Maybe (Vector.Vector TPut)} deriving (Show,Eq,Typeable)
instance Hashable PutMultiple_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_PutMultiple_args_table record   `hashWithSalt` f_PutMultiple_args_puts record  
write_PutMultiple_args oprot record = do
  writeStructBegin oprot "PutMultiple_args"
  case f_PutMultiple_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_PutMultiple_args_puts record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("puts",T_LIST,2)
    (let f = Vector.mapM_ (\_viter211 -> write_TPut oprot _viter211) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_PutMultiple_args_fields iprot record = do
  (_,_t213,_id214) <- readFieldBegin iprot
  if _t213 == T_STOP then return record else
    case _id214 of 
      1 -> if _t213 == T_STRING then do
        s <- readBinary iprot
        read_PutMultiple_args_fields iprot record{f_PutMultiple_args_table=Just s}
        else do
          skip iprot _t213
          read_PutMultiple_args_fields iprot record
      2 -> if _t213 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TPut iprot)) in do {(_etype218,_size215) <- readListBegin iprot; f _size215})
        read_PutMultiple_args_fields iprot record{f_PutMultiple_args_puts=Just s}
        else do
          skip iprot _t213
          read_PutMultiple_args_fields iprot record
      _ -> do
        skip iprot _t213
        readFieldEnd iprot
        read_PutMultiple_args_fields iprot record
read_PutMultiple_args iprot = do
  _ <- readStructBegin iprot
  record <- read_PutMultiple_args_fields iprot (PutMultiple_args{f_PutMultiple_args_table=Nothing,f_PutMultiple_args_puts=Nothing})
  readStructEnd iprot
  return record
data PutMultiple_result = PutMultiple_result{f_PutMultiple_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable PutMultiple_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_PutMultiple_result_io record  
write_PutMultiple_result oprot record = do
  writeStructBegin oprot "PutMultiple_result"
  case f_PutMultiple_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_PutMultiple_result_fields iprot record = do
  (_,_t223,_id224) <- readFieldBegin iprot
  if _t223 == T_STOP then return record else
    case _id224 of 
      1 -> if _t223 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_PutMultiple_result_fields iprot record{f_PutMultiple_result_io=Just s}
        else do
          skip iprot _t223
          read_PutMultiple_result_fields iprot record
      _ -> do
        skip iprot _t223
        readFieldEnd iprot
        read_PutMultiple_result_fields iprot record
read_PutMultiple_result iprot = do
  _ <- readStructBegin iprot
  record <- read_PutMultiple_result_fields iprot (PutMultiple_result{f_PutMultiple_result_io=Nothing})
  readStructEnd iprot
  return record
data DeleteSingle_args = DeleteSingle_args{f_DeleteSingle_args_table :: Maybe ByteString,f_DeleteSingle_args_deleteSingle :: Maybe TDelete} deriving (Show,Eq,Typeable)
instance Hashable DeleteSingle_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteSingle_args_table record   `hashWithSalt` f_DeleteSingle_args_deleteSingle record  
write_DeleteSingle_args oprot record = do
  writeStructBegin oprot "DeleteSingle_args"
  case f_DeleteSingle_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteSingle_args_deleteSingle record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("deleteSingle",T_STRUCT,2)
    write_TDelete oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteSingle_args_fields iprot record = do
  (_,_t228,_id229) <- readFieldBegin iprot
  if _t228 == T_STOP then return record else
    case _id229 of 
      1 -> if _t228 == T_STRING then do
        s <- readBinary iprot
        read_DeleteSingle_args_fields iprot record{f_DeleteSingle_args_table=Just s}
        else do
          skip iprot _t228
          read_DeleteSingle_args_fields iprot record
      2 -> if _t228 == T_STRUCT then do
        s <- (read_TDelete iprot)
        read_DeleteSingle_args_fields iprot record{f_DeleteSingle_args_deleteSingle=Just s}
        else do
          skip iprot _t228
          read_DeleteSingle_args_fields iprot record
      _ -> do
        skip iprot _t228
        readFieldEnd iprot
        read_DeleteSingle_args_fields iprot record
read_DeleteSingle_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteSingle_args_fields iprot (DeleteSingle_args{f_DeleteSingle_args_table=Nothing,f_DeleteSingle_args_deleteSingle=Nothing})
  readStructEnd iprot
  return record
data DeleteSingle_result = DeleteSingle_result{f_DeleteSingle_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable DeleteSingle_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteSingle_result_io record  
write_DeleteSingle_result oprot record = do
  writeStructBegin oprot "DeleteSingle_result"
  case f_DeleteSingle_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteSingle_result_fields iprot record = do
  (_,_t233,_id234) <- readFieldBegin iprot
  if _t233 == T_STOP then return record else
    case _id234 of 
      1 -> if _t233 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_DeleteSingle_result_fields iprot record{f_DeleteSingle_result_io=Just s}
        else do
          skip iprot _t233
          read_DeleteSingle_result_fields iprot record
      _ -> do
        skip iprot _t233
        readFieldEnd iprot
        read_DeleteSingle_result_fields iprot record
read_DeleteSingle_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteSingle_result_fields iprot (DeleteSingle_result{f_DeleteSingle_result_io=Nothing})
  readStructEnd iprot
  return record
data DeleteMultiple_args = DeleteMultiple_args{f_DeleteMultiple_args_table :: Maybe ByteString,f_DeleteMultiple_args_deletes :: Maybe (Vector.Vector TDelete)} deriving (Show,Eq,Typeable)
instance Hashable DeleteMultiple_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteMultiple_args_table record   `hashWithSalt` f_DeleteMultiple_args_deletes record  
write_DeleteMultiple_args oprot record = do
  writeStructBegin oprot "DeleteMultiple_args"
  case f_DeleteMultiple_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteMultiple_args_deletes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("deletes",T_LIST,2)
    (let f = Vector.mapM_ (\_viter237 -> write_TDelete oprot _viter237) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteMultiple_args_fields iprot record = do
  (_,_t239,_id240) <- readFieldBegin iprot
  if _t239 == T_STOP then return record else
    case _id240 of 
      1 -> if _t239 == T_STRING then do
        s <- readBinary iprot
        read_DeleteMultiple_args_fields iprot record{f_DeleteMultiple_args_table=Just s}
        else do
          skip iprot _t239
          read_DeleteMultiple_args_fields iprot record
      2 -> if _t239 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TDelete iprot)) in do {(_etype244,_size241) <- readListBegin iprot; f _size241})
        read_DeleteMultiple_args_fields iprot record{f_DeleteMultiple_args_deletes=Just s}
        else do
          skip iprot _t239
          read_DeleteMultiple_args_fields iprot record
      _ -> do
        skip iprot _t239
        readFieldEnd iprot
        read_DeleteMultiple_args_fields iprot record
read_DeleteMultiple_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteMultiple_args_fields iprot (DeleteMultiple_args{f_DeleteMultiple_args_table=Nothing,f_DeleteMultiple_args_deletes=Nothing})
  readStructEnd iprot
  return record
data DeleteMultiple_result = DeleteMultiple_result{f_DeleteMultiple_result_success :: Maybe (Vector.Vector TDelete),f_DeleteMultiple_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable DeleteMultiple_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteMultiple_result_success record   `hashWithSalt` f_DeleteMultiple_result_io record  
write_DeleteMultiple_result oprot record = do
  writeStructBegin oprot "DeleteMultiple_result"
  case f_DeleteMultiple_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter248 -> write_TDelete oprot _viter248) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_DeleteMultiple_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteMultiple_result_fields iprot record = do
  (_,_t250,_id251) <- readFieldBegin iprot
  if _t250 == T_STOP then return record else
    case _id251 of 
      0 -> if _t250 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TDelete iprot)) in do {(_etype255,_size252) <- readListBegin iprot; f _size252})
        read_DeleteMultiple_result_fields iprot record{f_DeleteMultiple_result_success=Just s}
        else do
          skip iprot _t250
          read_DeleteMultiple_result_fields iprot record
      1 -> if _t250 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_DeleteMultiple_result_fields iprot record{f_DeleteMultiple_result_io=Just s}
        else do
          skip iprot _t250
          read_DeleteMultiple_result_fields iprot record
      _ -> do
        skip iprot _t250
        readFieldEnd iprot
        read_DeleteMultiple_result_fields iprot record
read_DeleteMultiple_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteMultiple_result_fields iprot (DeleteMultiple_result{f_DeleteMultiple_result_success=Nothing,f_DeleteMultiple_result_io=Nothing})
  readStructEnd iprot
  return record
data CheckAndDelete_args = CheckAndDelete_args{f_CheckAndDelete_args_table :: Maybe ByteString,f_CheckAndDelete_args_row :: Maybe ByteString,f_CheckAndDelete_args_family :: Maybe ByteString,f_CheckAndDelete_args_qualifier :: Maybe ByteString,f_CheckAndDelete_args_value :: Maybe ByteString,f_CheckAndDelete_args_deleteSingle :: Maybe TDelete} deriving (Show,Eq,Typeable)
instance Hashable CheckAndDelete_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CheckAndDelete_args_table record   `hashWithSalt` f_CheckAndDelete_args_row record   `hashWithSalt` f_CheckAndDelete_args_family record   `hashWithSalt` f_CheckAndDelete_args_qualifier record   `hashWithSalt` f_CheckAndDelete_args_value record   `hashWithSalt` f_CheckAndDelete_args_deleteSingle record  
write_CheckAndDelete_args oprot record = do
  writeStructBegin oprot "CheckAndDelete_args"
  case f_CheckAndDelete_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CheckAndDelete_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CheckAndDelete_args_family record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("family",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CheckAndDelete_args_qualifier record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("qualifier",T_STRING,4)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CheckAndDelete_args_value record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("value",T_STRING,5)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CheckAndDelete_args_deleteSingle record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("deleteSingle",T_STRUCT,6)
    write_TDelete oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CheckAndDelete_args_fields iprot record = do
  (_,_t260,_id261) <- readFieldBegin iprot
  if _t260 == T_STOP then return record else
    case _id261 of 
      1 -> if _t260 == T_STRING then do
        s <- readBinary iprot
        read_CheckAndDelete_args_fields iprot record{f_CheckAndDelete_args_table=Just s}
        else do
          skip iprot _t260
          read_CheckAndDelete_args_fields iprot record
      2 -> if _t260 == T_STRING then do
        s <- readBinary iprot
        read_CheckAndDelete_args_fields iprot record{f_CheckAndDelete_args_row=Just s}
        else do
          skip iprot _t260
          read_CheckAndDelete_args_fields iprot record
      3 -> if _t260 == T_STRING then do
        s <- readBinary iprot
        read_CheckAndDelete_args_fields iprot record{f_CheckAndDelete_args_family=Just s}
        else do
          skip iprot _t260
          read_CheckAndDelete_args_fields iprot record
      4 -> if _t260 == T_STRING then do
        s <- readBinary iprot
        read_CheckAndDelete_args_fields iprot record{f_CheckAndDelete_args_qualifier=Just s}
        else do
          skip iprot _t260
          read_CheckAndDelete_args_fields iprot record
      5 -> if _t260 == T_STRING then do
        s <- readBinary iprot
        read_CheckAndDelete_args_fields iprot record{f_CheckAndDelete_args_value=Just s}
        else do
          skip iprot _t260
          read_CheckAndDelete_args_fields iprot record
      6 -> if _t260 == T_STRUCT then do
        s <- (read_TDelete iprot)
        read_CheckAndDelete_args_fields iprot record{f_CheckAndDelete_args_deleteSingle=Just s}
        else do
          skip iprot _t260
          read_CheckAndDelete_args_fields iprot record
      _ -> do
        skip iprot _t260
        readFieldEnd iprot
        read_CheckAndDelete_args_fields iprot record
read_CheckAndDelete_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CheckAndDelete_args_fields iprot (CheckAndDelete_args{f_CheckAndDelete_args_table=Nothing,f_CheckAndDelete_args_row=Nothing,f_CheckAndDelete_args_family=Nothing,f_CheckAndDelete_args_qualifier=Nothing,f_CheckAndDelete_args_value=Nothing,f_CheckAndDelete_args_deleteSingle=Nothing})
  readStructEnd iprot
  return record
data CheckAndDelete_result = CheckAndDelete_result{f_CheckAndDelete_result_success :: Maybe Bool,f_CheckAndDelete_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable CheckAndDelete_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CheckAndDelete_result_success record   `hashWithSalt` f_CheckAndDelete_result_io record  
write_CheckAndDelete_result oprot record = do
  writeStructBegin oprot "CheckAndDelete_result"
  case f_CheckAndDelete_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_BOOL,0)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_CheckAndDelete_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CheckAndDelete_result_fields iprot record = do
  (_,_t265,_id266) <- readFieldBegin iprot
  if _t265 == T_STOP then return record else
    case _id266 of 
      0 -> if _t265 == T_BOOL then do
        s <- readBool iprot
        read_CheckAndDelete_result_fields iprot record{f_CheckAndDelete_result_success=Just s}
        else do
          skip iprot _t265
          read_CheckAndDelete_result_fields iprot record
      1 -> if _t265 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_CheckAndDelete_result_fields iprot record{f_CheckAndDelete_result_io=Just s}
        else do
          skip iprot _t265
          read_CheckAndDelete_result_fields iprot record
      _ -> do
        skip iprot _t265
        readFieldEnd iprot
        read_CheckAndDelete_result_fields iprot record
read_CheckAndDelete_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CheckAndDelete_result_fields iprot (CheckAndDelete_result{f_CheckAndDelete_result_success=Nothing,f_CheckAndDelete_result_io=Nothing})
  readStructEnd iprot
  return record
data Increment_args = Increment_args{f_Increment_args_table :: Maybe ByteString,f_Increment_args_increment :: Maybe TIncrement} deriving (Show,Eq,Typeable)
instance Hashable Increment_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Increment_args_table record   `hashWithSalt` f_Increment_args_increment record  
write_Increment_args oprot record = do
  writeStructBegin oprot "Increment_args"
  case f_Increment_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Increment_args_increment record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("increment",T_STRUCT,2)
    write_TIncrement oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Increment_args_fields iprot record = do
  (_,_t270,_id271) <- readFieldBegin iprot
  if _t270 == T_STOP then return record else
    case _id271 of 
      1 -> if _t270 == T_STRING then do
        s <- readBinary iprot
        read_Increment_args_fields iprot record{f_Increment_args_table=Just s}
        else do
          skip iprot _t270
          read_Increment_args_fields iprot record
      2 -> if _t270 == T_STRUCT then do
        s <- (read_TIncrement iprot)
        read_Increment_args_fields iprot record{f_Increment_args_increment=Just s}
        else do
          skip iprot _t270
          read_Increment_args_fields iprot record
      _ -> do
        skip iprot _t270
        readFieldEnd iprot
        read_Increment_args_fields iprot record
read_Increment_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Increment_args_fields iprot (Increment_args{f_Increment_args_table=Nothing,f_Increment_args_increment=Nothing})
  readStructEnd iprot
  return record
data Increment_result = Increment_result{f_Increment_result_success :: Maybe TResult,f_Increment_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable Increment_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Increment_result_success record   `hashWithSalt` f_Increment_result_io record  
write_Increment_result oprot record = do
  writeStructBegin oprot "Increment_result"
  case f_Increment_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    write_TResult oprot _v
    writeFieldEnd oprot}
  case f_Increment_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Increment_result_fields iprot record = do
  (_,_t275,_id276) <- readFieldBegin iprot
  if _t275 == T_STOP then return record else
    case _id276 of 
      0 -> if _t275 == T_STRUCT then do
        s <- (read_TResult iprot)
        read_Increment_result_fields iprot record{f_Increment_result_success=Just s}
        else do
          skip iprot _t275
          read_Increment_result_fields iprot record
      1 -> if _t275 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_Increment_result_fields iprot record{f_Increment_result_io=Just s}
        else do
          skip iprot _t275
          read_Increment_result_fields iprot record
      _ -> do
        skip iprot _t275
        readFieldEnd iprot
        read_Increment_result_fields iprot record
read_Increment_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Increment_result_fields iprot (Increment_result{f_Increment_result_success=Nothing,f_Increment_result_io=Nothing})
  readStructEnd iprot
  return record
data OpenScanner_args = OpenScanner_args{f_OpenScanner_args_table :: Maybe ByteString,f_OpenScanner_args_scan :: Maybe TScan} deriving (Show,Eq,Typeable)
instance Hashable OpenScanner_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_OpenScanner_args_table record   `hashWithSalt` f_OpenScanner_args_scan record  
write_OpenScanner_args oprot record = do
  writeStructBegin oprot "OpenScanner_args"
  case f_OpenScanner_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_OpenScanner_args_scan record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("scan",T_STRUCT,2)
    write_TScan oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_OpenScanner_args_fields iprot record = do
  (_,_t280,_id281) <- readFieldBegin iprot
  if _t280 == T_STOP then return record else
    case _id281 of 
      1 -> if _t280 == T_STRING then do
        s <- readBinary iprot
        read_OpenScanner_args_fields iprot record{f_OpenScanner_args_table=Just s}
        else do
          skip iprot _t280
          read_OpenScanner_args_fields iprot record
      2 -> if _t280 == T_STRUCT then do
        s <- (read_TScan iprot)
        read_OpenScanner_args_fields iprot record{f_OpenScanner_args_scan=Just s}
        else do
          skip iprot _t280
          read_OpenScanner_args_fields iprot record
      _ -> do
        skip iprot _t280
        readFieldEnd iprot
        read_OpenScanner_args_fields iprot record
read_OpenScanner_args iprot = do
  _ <- readStructBegin iprot
  record <- read_OpenScanner_args_fields iprot (OpenScanner_args{f_OpenScanner_args_table=Nothing,f_OpenScanner_args_scan=Nothing})
  readStructEnd iprot
  return record
data OpenScanner_result = OpenScanner_result{f_OpenScanner_result_success :: Maybe Int32,f_OpenScanner_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable OpenScanner_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_OpenScanner_result_success record   `hashWithSalt` f_OpenScanner_result_io record  
write_OpenScanner_result oprot record = do
  writeStructBegin oprot "OpenScanner_result"
  case f_OpenScanner_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_I32,0)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_OpenScanner_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_OpenScanner_result_fields iprot record = do
  (_,_t285,_id286) <- readFieldBegin iprot
  if _t285 == T_STOP then return record else
    case _id286 of 
      0 -> if _t285 == T_I32 then do
        s <- readI32 iprot
        read_OpenScanner_result_fields iprot record{f_OpenScanner_result_success=Just s}
        else do
          skip iprot _t285
          read_OpenScanner_result_fields iprot record
      1 -> if _t285 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_OpenScanner_result_fields iprot record{f_OpenScanner_result_io=Just s}
        else do
          skip iprot _t285
          read_OpenScanner_result_fields iprot record
      _ -> do
        skip iprot _t285
        readFieldEnd iprot
        read_OpenScanner_result_fields iprot record
read_OpenScanner_result iprot = do
  _ <- readStructBegin iprot
  record <- read_OpenScanner_result_fields iprot (OpenScanner_result{f_OpenScanner_result_success=Nothing,f_OpenScanner_result_io=Nothing})
  readStructEnd iprot
  return record
data GetScannerRows_args = GetScannerRows_args{f_GetScannerRows_args_scannerId :: Maybe Int32,f_GetScannerRows_args_numRows :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable GetScannerRows_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetScannerRows_args_scannerId record   `hashWithSalt` f_GetScannerRows_args_numRows record  
write_GetScannerRows_args oprot record = do
  writeStructBegin oprot "GetScannerRows_args"
  case f_GetScannerRows_args_scannerId record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("scannerId",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_GetScannerRows_args_numRows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("numRows",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetScannerRows_args_fields iprot record = do
  (_,_t290,_id291) <- readFieldBegin iprot
  if _t290 == T_STOP then return record else
    case _id291 of 
      1 -> if _t290 == T_I32 then do
        s <- readI32 iprot
        read_GetScannerRows_args_fields iprot record{f_GetScannerRows_args_scannerId=Just s}
        else do
          skip iprot _t290
          read_GetScannerRows_args_fields iprot record
      2 -> if _t290 == T_I32 then do
        s <- readI32 iprot
        read_GetScannerRows_args_fields iprot record{f_GetScannerRows_args_numRows=Just s}
        else do
          skip iprot _t290
          read_GetScannerRows_args_fields iprot record
      _ -> do
        skip iprot _t290
        readFieldEnd iprot
        read_GetScannerRows_args_fields iprot record
read_GetScannerRows_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetScannerRows_args_fields iprot (GetScannerRows_args{f_GetScannerRows_args_scannerId=Nothing,f_GetScannerRows_args_numRows=Nothing})
  readStructEnd iprot
  return record
data GetScannerRows_result = GetScannerRows_result{f_GetScannerRows_result_success :: Maybe (Vector.Vector TResult),f_GetScannerRows_result_io :: Maybe TIOError,f_GetScannerRows_result_ia :: Maybe TIllegalArgument} deriving (Show,Eq,Typeable)
instance Hashable GetScannerRows_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetScannerRows_result_success record   `hashWithSalt` f_GetScannerRows_result_io record   `hashWithSalt` f_GetScannerRows_result_ia record  
write_GetScannerRows_result oprot record = do
  writeStructBegin oprot "GetScannerRows_result"
  case f_GetScannerRows_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter294 -> write_TResult oprot _viter294) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetScannerRows_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  case f_GetScannerRows_result_ia record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ia",T_STRUCT,2)
    write_TIllegalArgument oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetScannerRows_result_fields iprot record = do
  (_,_t296,_id297) <- readFieldBegin iprot
  if _t296 == T_STOP then return record else
    case _id297 of 
      0 -> if _t296 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TResult iprot)) in do {(_etype301,_size298) <- readListBegin iprot; f _size298})
        read_GetScannerRows_result_fields iprot record{f_GetScannerRows_result_success=Just s}
        else do
          skip iprot _t296
          read_GetScannerRows_result_fields iprot record
      1 -> if _t296 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_GetScannerRows_result_fields iprot record{f_GetScannerRows_result_io=Just s}
        else do
          skip iprot _t296
          read_GetScannerRows_result_fields iprot record
      2 -> if _t296 == T_STRUCT then do
        s <- (read_TIllegalArgument iprot)
        read_GetScannerRows_result_fields iprot record{f_GetScannerRows_result_ia=Just s}
        else do
          skip iprot _t296
          read_GetScannerRows_result_fields iprot record
      _ -> do
        skip iprot _t296
        readFieldEnd iprot
        read_GetScannerRows_result_fields iprot record
read_GetScannerRows_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetScannerRows_result_fields iprot (GetScannerRows_result{f_GetScannerRows_result_success=Nothing,f_GetScannerRows_result_io=Nothing,f_GetScannerRows_result_ia=Nothing})
  readStructEnd iprot
  return record
data CloseScanner_args = CloseScanner_args{f_CloseScanner_args_scannerId :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable CloseScanner_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CloseScanner_args_scannerId record  
write_CloseScanner_args oprot record = do
  writeStructBegin oprot "CloseScanner_args"
  case f_CloseScanner_args_scannerId record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("scannerId",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CloseScanner_args_fields iprot record = do
  (_,_t306,_id307) <- readFieldBegin iprot
  if _t306 == T_STOP then return record else
    case _id307 of 
      1 -> if _t306 == T_I32 then do
        s <- readI32 iprot
        read_CloseScanner_args_fields iprot record{f_CloseScanner_args_scannerId=Just s}
        else do
          skip iprot _t306
          read_CloseScanner_args_fields iprot record
      _ -> do
        skip iprot _t306
        readFieldEnd iprot
        read_CloseScanner_args_fields iprot record
read_CloseScanner_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CloseScanner_args_fields iprot (CloseScanner_args{f_CloseScanner_args_scannerId=Nothing})
  readStructEnd iprot
  return record
data CloseScanner_result = CloseScanner_result{f_CloseScanner_result_io :: Maybe TIOError,f_CloseScanner_result_ia :: Maybe TIllegalArgument} deriving (Show,Eq,Typeable)
instance Hashable CloseScanner_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CloseScanner_result_io record   `hashWithSalt` f_CloseScanner_result_ia record  
write_CloseScanner_result oprot record = do
  writeStructBegin oprot "CloseScanner_result"
  case f_CloseScanner_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  case f_CloseScanner_result_ia record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ia",T_STRUCT,2)
    write_TIllegalArgument oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CloseScanner_result_fields iprot record = do
  (_,_t311,_id312) <- readFieldBegin iprot
  if _t311 == T_STOP then return record else
    case _id312 of 
      1 -> if _t311 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_CloseScanner_result_fields iprot record{f_CloseScanner_result_io=Just s}
        else do
          skip iprot _t311
          read_CloseScanner_result_fields iprot record
      2 -> if _t311 == T_STRUCT then do
        s <- (read_TIllegalArgument iprot)
        read_CloseScanner_result_fields iprot record{f_CloseScanner_result_ia=Just s}
        else do
          skip iprot _t311
          read_CloseScanner_result_fields iprot record
      _ -> do
        skip iprot _t311
        readFieldEnd iprot
        read_CloseScanner_result_fields iprot record
read_CloseScanner_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CloseScanner_result_fields iprot (CloseScanner_result{f_CloseScanner_result_io=Nothing,f_CloseScanner_result_ia=Nothing})
  readStructEnd iprot
  return record
data MutateRow_args = MutateRow_args{f_MutateRow_args_table :: Maybe ByteString,f_MutateRow_args_rowMutations :: Maybe TRowMutations} deriving (Show,Eq,Typeable)
instance Hashable MutateRow_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_MutateRow_args_table record   `hashWithSalt` f_MutateRow_args_rowMutations record  
write_MutateRow_args oprot record = do
  writeStructBegin oprot "MutateRow_args"
  case f_MutateRow_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_MutateRow_args_rowMutations record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rowMutations",T_STRUCT,2)
    write_TRowMutations oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MutateRow_args_fields iprot record = do
  (_,_t316,_id317) <- readFieldBegin iprot
  if _t316 == T_STOP then return record else
    case _id317 of 
      1 -> if _t316 == T_STRING then do
        s <- readBinary iprot
        read_MutateRow_args_fields iprot record{f_MutateRow_args_table=Just s}
        else do
          skip iprot _t316
          read_MutateRow_args_fields iprot record
      2 -> if _t316 == T_STRUCT then do
        s <- (read_TRowMutations iprot)
        read_MutateRow_args_fields iprot record{f_MutateRow_args_rowMutations=Just s}
        else do
          skip iprot _t316
          read_MutateRow_args_fields iprot record
      _ -> do
        skip iprot _t316
        readFieldEnd iprot
        read_MutateRow_args_fields iprot record
read_MutateRow_args iprot = do
  _ <- readStructBegin iprot
  record <- read_MutateRow_args_fields iprot (MutateRow_args{f_MutateRow_args_table=Nothing,f_MutateRow_args_rowMutations=Nothing})
  readStructEnd iprot
  return record
data MutateRow_result = MutateRow_result{f_MutateRow_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable MutateRow_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_MutateRow_result_io record  
write_MutateRow_result oprot record = do
  writeStructBegin oprot "MutateRow_result"
  case f_MutateRow_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MutateRow_result_fields iprot record = do
  (_,_t321,_id322) <- readFieldBegin iprot
  if _t321 == T_STOP then return record else
    case _id322 of 
      1 -> if _t321 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_MutateRow_result_fields iprot record{f_MutateRow_result_io=Just s}
        else do
          skip iprot _t321
          read_MutateRow_result_fields iprot record
      _ -> do
        skip iprot _t321
        readFieldEnd iprot
        read_MutateRow_result_fields iprot record
read_MutateRow_result iprot = do
  _ <- readStructBegin iprot
  record <- read_MutateRow_result_fields iprot (MutateRow_result{f_MutateRow_result_io=Nothing})
  readStructEnd iprot
  return record
data GetScannerResults_args = GetScannerResults_args{f_GetScannerResults_args_table :: Maybe ByteString,f_GetScannerResults_args_scan :: Maybe TScan,f_GetScannerResults_args_numRows :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable GetScannerResults_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetScannerResults_args_table record   `hashWithSalt` f_GetScannerResults_args_scan record   `hashWithSalt` f_GetScannerResults_args_numRows record  
write_GetScannerResults_args oprot record = do
  writeStructBegin oprot "GetScannerResults_args"
  case f_GetScannerResults_args_table record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("table",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetScannerResults_args_scan record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("scan",T_STRUCT,2)
    write_TScan oprot _v
    writeFieldEnd oprot}
  case f_GetScannerResults_args_numRows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("numRows",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetScannerResults_args_fields iprot record = do
  (_,_t326,_id327) <- readFieldBegin iprot
  if _t326 == T_STOP then return record else
    case _id327 of 
      1 -> if _t326 == T_STRING then do
        s <- readBinary iprot
        read_GetScannerResults_args_fields iprot record{f_GetScannerResults_args_table=Just s}
        else do
          skip iprot _t326
          read_GetScannerResults_args_fields iprot record
      2 -> if _t326 == T_STRUCT then do
        s <- (read_TScan iprot)
        read_GetScannerResults_args_fields iprot record{f_GetScannerResults_args_scan=Just s}
        else do
          skip iprot _t326
          read_GetScannerResults_args_fields iprot record
      3 -> if _t326 == T_I32 then do
        s <- readI32 iprot
        read_GetScannerResults_args_fields iprot record{f_GetScannerResults_args_numRows=Just s}
        else do
          skip iprot _t326
          read_GetScannerResults_args_fields iprot record
      _ -> do
        skip iprot _t326
        readFieldEnd iprot
        read_GetScannerResults_args_fields iprot record
read_GetScannerResults_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetScannerResults_args_fields iprot (GetScannerResults_args{f_GetScannerResults_args_table=Nothing,f_GetScannerResults_args_scan=Nothing,f_GetScannerResults_args_numRows=Nothing})
  readStructEnd iprot
  return record
data GetScannerResults_result = GetScannerResults_result{f_GetScannerResults_result_success :: Maybe (Vector.Vector TResult),f_GetScannerResults_result_io :: Maybe TIOError} deriving (Show,Eq,Typeable)
instance Hashable GetScannerResults_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetScannerResults_result_success record   `hashWithSalt` f_GetScannerResults_result_io record  
write_GetScannerResults_result oprot record = do
  writeStructBegin oprot "GetScannerResults_result"
  case f_GetScannerResults_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter330 -> write_TResult oprot _viter330) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetScannerResults_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_TIOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetScannerResults_result_fields iprot record = do
  (_,_t332,_id333) <- readFieldBegin iprot
  if _t332 == T_STOP then return record else
    case _id333 of 
      0 -> if _t332 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TResult iprot)) in do {(_etype337,_size334) <- readListBegin iprot; f _size334})
        read_GetScannerResults_result_fields iprot record{f_GetScannerResults_result_success=Just s}
        else do
          skip iprot _t332
          read_GetScannerResults_result_fields iprot record
      1 -> if _t332 == T_STRUCT then do
        s <- (read_TIOError iprot)
        read_GetScannerResults_result_fields iprot record{f_GetScannerResults_result_io=Just s}
        else do
          skip iprot _t332
          read_GetScannerResults_result_fields iprot record
      _ -> do
        skip iprot _t332
        readFieldEnd iprot
        read_GetScannerResults_result_fields iprot record
read_GetScannerResults_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetScannerResults_result_fields iprot (GetScannerResults_result{f_GetScannerResults_result_success=Nothing,f_GetScannerResults_result_io=Nothing})
  readStructEnd iprot
  return record
process_exists (seqid, iprot, oprot, handler) = do
  args <- read_Exists_args iprot
  readMessageEnd iprot
  rs <- return (Exists_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.exists handler (f_Exists_args_table args) (f_Exists_args_get args)
      return rs{f_Exists_result_success= Just res})
    (\e  -> 
      return rs{f_Exists_result_io =Just e}))
  writeMessageBegin oprot ("exists", M_REPLY, seqid);
  write_Exists_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_get (seqid, iprot, oprot, handler) = do
  args <- read_Get_args iprot
  readMessageEnd iprot
  rs <- return (Get_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.get handler (f_Get_args_table args) (f_Get_args_get args)
      return rs{f_Get_result_success= Just res})
    (\e  -> 
      return rs{f_Get_result_io =Just e}))
  writeMessageBegin oprot ("get", M_REPLY, seqid);
  write_Get_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getMultiple (seqid, iprot, oprot, handler) = do
  args <- read_GetMultiple_args iprot
  readMessageEnd iprot
  rs <- return (GetMultiple_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getMultiple handler (f_GetMultiple_args_table args) (f_GetMultiple_args_gets args)
      return rs{f_GetMultiple_result_success= Just res})
    (\e  -> 
      return rs{f_GetMultiple_result_io =Just e}))
  writeMessageBegin oprot ("getMultiple", M_REPLY, seqid);
  write_GetMultiple_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_put (seqid, iprot, oprot, handler) = do
  args <- read_Put_args iprot
  readMessageEnd iprot
  rs <- return (Put_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.put handler (f_Put_args_table args) (f_Put_args_put args)
      return rs)
    (\e  -> 
      return rs{f_Put_result_io =Just e}))
  writeMessageBegin oprot ("put", M_REPLY, seqid);
  write_Put_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_checkAndPut (seqid, iprot, oprot, handler) = do
  args <- read_CheckAndPut_args iprot
  readMessageEnd iprot
  rs <- return (CheckAndPut_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.checkAndPut handler (f_CheckAndPut_args_table args) (f_CheckAndPut_args_row args) (f_CheckAndPut_args_family args) (f_CheckAndPut_args_qualifier args) (f_CheckAndPut_args_value args) (f_CheckAndPut_args_put args)
      return rs{f_CheckAndPut_result_success= Just res})
    (\e  -> 
      return rs{f_CheckAndPut_result_io =Just e}))
  writeMessageBegin oprot ("checkAndPut", M_REPLY, seqid);
  write_CheckAndPut_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_putMultiple (seqid, iprot, oprot, handler) = do
  args <- read_PutMultiple_args iprot
  readMessageEnd iprot
  rs <- return (PutMultiple_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.putMultiple handler (f_PutMultiple_args_table args) (f_PutMultiple_args_puts args)
      return rs)
    (\e  -> 
      return rs{f_PutMultiple_result_io =Just e}))
  writeMessageBegin oprot ("putMultiple", M_REPLY, seqid);
  write_PutMultiple_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_deleteSingle (seqid, iprot, oprot, handler) = do
  args <- read_DeleteSingle_args iprot
  readMessageEnd iprot
  rs <- return (DeleteSingle_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.deleteSingle handler (f_DeleteSingle_args_table args) (f_DeleteSingle_args_deleteSingle args)
      return rs)
    (\e  -> 
      return rs{f_DeleteSingle_result_io =Just e}))
  writeMessageBegin oprot ("deleteSingle", M_REPLY, seqid);
  write_DeleteSingle_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_deleteMultiple (seqid, iprot, oprot, handler) = do
  args <- read_DeleteMultiple_args iprot
  readMessageEnd iprot
  rs <- return (DeleteMultiple_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.deleteMultiple handler (f_DeleteMultiple_args_table args) (f_DeleteMultiple_args_deletes args)
      return rs{f_DeleteMultiple_result_success= Just res})
    (\e  -> 
      return rs{f_DeleteMultiple_result_io =Just e}))
  writeMessageBegin oprot ("deleteMultiple", M_REPLY, seqid);
  write_DeleteMultiple_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_checkAndDelete (seqid, iprot, oprot, handler) = do
  args <- read_CheckAndDelete_args iprot
  readMessageEnd iprot
  rs <- return (CheckAndDelete_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.checkAndDelete handler (f_CheckAndDelete_args_table args) (f_CheckAndDelete_args_row args) (f_CheckAndDelete_args_family args) (f_CheckAndDelete_args_qualifier args) (f_CheckAndDelete_args_value args) (f_CheckAndDelete_args_deleteSingle args)
      return rs{f_CheckAndDelete_result_success= Just res})
    (\e  -> 
      return rs{f_CheckAndDelete_result_io =Just e}))
  writeMessageBegin oprot ("checkAndDelete", M_REPLY, seqid);
  write_CheckAndDelete_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_increment (seqid, iprot, oprot, handler) = do
  args <- read_Increment_args iprot
  readMessageEnd iprot
  rs <- return (Increment_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.increment handler (f_Increment_args_table args) (f_Increment_args_increment args)
      return rs{f_Increment_result_success= Just res})
    (\e  -> 
      return rs{f_Increment_result_io =Just e}))
  writeMessageBegin oprot ("increment", M_REPLY, seqid);
  write_Increment_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_openScanner (seqid, iprot, oprot, handler) = do
  args <- read_OpenScanner_args iprot
  readMessageEnd iprot
  rs <- return (OpenScanner_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.openScanner handler (f_OpenScanner_args_table args) (f_OpenScanner_args_scan args)
      return rs{f_OpenScanner_result_success= Just res})
    (\e  -> 
      return rs{f_OpenScanner_result_io =Just e}))
  writeMessageBegin oprot ("openScanner", M_REPLY, seqid);
  write_OpenScanner_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getScannerRows (seqid, iprot, oprot, handler) = do
  args <- read_GetScannerRows_args iprot
  readMessageEnd iprot
  rs <- return (GetScannerRows_result Nothing Nothing Nothing)
  res <- (Control.Exception.catch
    (Control.Exception.catch
      (do
        res <- Iface.getScannerRows handler (f_GetScannerRows_args_scannerId args) (f_GetScannerRows_args_numRows args)
        return rs{f_GetScannerRows_result_success= Just res})
      (\e  -> 
        return rs{f_GetScannerRows_result_io =Just e}))
    (\e  -> 
      return rs{f_GetScannerRows_result_ia =Just e}))
  writeMessageBegin oprot ("getScannerRows", M_REPLY, seqid);
  write_GetScannerRows_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_closeScanner (seqid, iprot, oprot, handler) = do
  args <- read_CloseScanner_args iprot
  readMessageEnd iprot
  rs <- return (CloseScanner_result Nothing Nothing)
  res <- (Control.Exception.catch
    (Control.Exception.catch
      (do
        Iface.closeScanner handler (f_CloseScanner_args_scannerId args)
        return rs)
      (\e  -> 
        return rs{f_CloseScanner_result_io =Just e}))
    (\e  -> 
      return rs{f_CloseScanner_result_ia =Just e}))
  writeMessageBegin oprot ("closeScanner", M_REPLY, seqid);
  write_CloseScanner_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_mutateRow (seqid, iprot, oprot, handler) = do
  args <- read_MutateRow_args iprot
  readMessageEnd iprot
  rs <- return (MutateRow_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.mutateRow handler (f_MutateRow_args_table args) (f_MutateRow_args_rowMutations args)
      return rs)
    (\e  -> 
      return rs{f_MutateRow_result_io =Just e}))
  writeMessageBegin oprot ("mutateRow", M_REPLY, seqid);
  write_MutateRow_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getScannerResults (seqid, iprot, oprot, handler) = do
  args <- read_GetScannerResults_args iprot
  readMessageEnd iprot
  rs <- return (GetScannerResults_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getScannerResults handler (f_GetScannerResults_args_table args) (f_GetScannerResults_args_scan args) (f_GetScannerResults_args_numRows args)
      return rs{f_GetScannerResults_result_success= Just res})
    (\e  -> 
      return rs{f_GetScannerResults_result_io =Just e}))
  writeMessageBegin oprot ("getScannerResults", M_REPLY, seqid);
  write_GetScannerResults_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "exists" -> process_exists (seqid,iprot,oprot,handler)
  "get" -> process_get (seqid,iprot,oprot,handler)
  "getMultiple" -> process_getMultiple (seqid,iprot,oprot,handler)
  "put" -> process_put (seqid,iprot,oprot,handler)
  "checkAndPut" -> process_checkAndPut (seqid,iprot,oprot,handler)
  "putMultiple" -> process_putMultiple (seqid,iprot,oprot,handler)
  "deleteSingle" -> process_deleteSingle (seqid,iprot,oprot,handler)
  "deleteMultiple" -> process_deleteMultiple (seqid,iprot,oprot,handler)
  "checkAndDelete" -> process_checkAndDelete (seqid,iprot,oprot,handler)
  "increment" -> process_increment (seqid,iprot,oprot,handler)
  "openScanner" -> process_openScanner (seqid,iprot,oprot,handler)
  "getScannerRows" -> process_getScannerRows (seqid,iprot,oprot,handler)
  "closeScanner" -> process_closeScanner (seqid,iprot,oprot,handler)
  "mutateRow" -> process_mutateRow (seqid,iprot,oprot,handler)
  "getScannerResults" -> process_getScannerResults (seqid,iprot,oprot,handler)
  _ -> do
    skip iprot T_STRUCT
    readMessageEnd iprot
    writeMessageBegin oprot (name,M_EXCEPTION,seqid)
    writeAppExn oprot (AppExn AE_UNKNOWN_METHOD ("Unknown function " ++ TL.unpack name))
    writeMessageEnd oprot
    tFlush (getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  return True
