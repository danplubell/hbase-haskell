{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Database.Hbase.Hbase where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()


import Database.Hbase.Hbase_Types
import qualified Database.Hbase.Hbase_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data EnableTable_args = EnableTable_args{f_EnableTable_args_tableName :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable EnableTable_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_EnableTable_args_tableName record  
write_EnableTable_args oprot record = do
  writeStructBegin oprot "EnableTable_args"
  case f_EnableTable_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_EnableTable_args_fields iprot record = do
  (_,_t88,_id89) <- readFieldBegin iprot
  if _t88 == T_STOP then return record else
    case _id89 of 
      1 -> if _t88 == T_STRING then do
        s <- readBinary iprot
        read_EnableTable_args_fields iprot record{f_EnableTable_args_tableName=Just s}
        else do
          skip iprot _t88
          read_EnableTable_args_fields iprot record
      _ -> do
        skip iprot _t88
        readFieldEnd iprot
        read_EnableTable_args_fields iprot record
read_EnableTable_args iprot = do
  _ <- readStructBegin iprot
  record <- read_EnableTable_args_fields iprot (EnableTable_args{f_EnableTable_args_tableName=Nothing})
  readStructEnd iprot
  return record
data EnableTable_result = EnableTable_result{f_EnableTable_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable EnableTable_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_EnableTable_result_io record  
write_EnableTable_result oprot record = do
  writeStructBegin oprot "EnableTable_result"
  case f_EnableTable_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_EnableTable_result_fields iprot record = do
  (_,_t93,_id94) <- readFieldBegin iprot
  if _t93 == T_STOP then return record else
    case _id94 of 
      1 -> if _t93 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_EnableTable_result_fields iprot record{f_EnableTable_result_io=Just s}
        else do
          skip iprot _t93
          read_EnableTable_result_fields iprot record
      _ -> do
        skip iprot _t93
        readFieldEnd iprot
        read_EnableTable_result_fields iprot record
read_EnableTable_result iprot = do
  _ <- readStructBegin iprot
  record <- read_EnableTable_result_fields iprot (EnableTable_result{f_EnableTable_result_io=Nothing})
  readStructEnd iprot
  return record
data DisableTable_args = DisableTable_args{f_DisableTable_args_tableName :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable DisableTable_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DisableTable_args_tableName record  
write_DisableTable_args oprot record = do
  writeStructBegin oprot "DisableTable_args"
  case f_DisableTable_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DisableTable_args_fields iprot record = do
  (_,_t98,_id99) <- readFieldBegin iprot
  if _t98 == T_STOP then return record else
    case _id99 of 
      1 -> if _t98 == T_STRING then do
        s <- readBinary iprot
        read_DisableTable_args_fields iprot record{f_DisableTable_args_tableName=Just s}
        else do
          skip iprot _t98
          read_DisableTable_args_fields iprot record
      _ -> do
        skip iprot _t98
        readFieldEnd iprot
        read_DisableTable_args_fields iprot record
read_DisableTable_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DisableTable_args_fields iprot (DisableTable_args{f_DisableTable_args_tableName=Nothing})
  readStructEnd iprot
  return record
data DisableTable_result = DisableTable_result{f_DisableTable_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable DisableTable_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DisableTable_result_io record  
write_DisableTable_result oprot record = do
  writeStructBegin oprot "DisableTable_result"
  case f_DisableTable_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DisableTable_result_fields iprot record = do
  (_,_t103,_id104) <- readFieldBegin iprot
  if _t103 == T_STOP then return record else
    case _id104 of 
      1 -> if _t103 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_DisableTable_result_fields iprot record{f_DisableTable_result_io=Just s}
        else do
          skip iprot _t103
          read_DisableTable_result_fields iprot record
      _ -> do
        skip iprot _t103
        readFieldEnd iprot
        read_DisableTable_result_fields iprot record
read_DisableTable_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DisableTable_result_fields iprot (DisableTable_result{f_DisableTable_result_io=Nothing})
  readStructEnd iprot
  return record
data IsTableEnabled_args = IsTableEnabled_args{f_IsTableEnabled_args_tableName :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable IsTableEnabled_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_IsTableEnabled_args_tableName record  
write_IsTableEnabled_args oprot record = do
  writeStructBegin oprot "IsTableEnabled_args"
  case f_IsTableEnabled_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_IsTableEnabled_args_fields iprot record = do
  (_,_t108,_id109) <- readFieldBegin iprot
  if _t108 == T_STOP then return record else
    case _id109 of 
      1 -> if _t108 == T_STRING then do
        s <- readBinary iprot
        read_IsTableEnabled_args_fields iprot record{f_IsTableEnabled_args_tableName=Just s}
        else do
          skip iprot _t108
          read_IsTableEnabled_args_fields iprot record
      _ -> do
        skip iprot _t108
        readFieldEnd iprot
        read_IsTableEnabled_args_fields iprot record
read_IsTableEnabled_args iprot = do
  _ <- readStructBegin iprot
  record <- read_IsTableEnabled_args_fields iprot (IsTableEnabled_args{f_IsTableEnabled_args_tableName=Nothing})
  readStructEnd iprot
  return record
data IsTableEnabled_result = IsTableEnabled_result{f_IsTableEnabled_result_success :: Maybe Bool,f_IsTableEnabled_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable IsTableEnabled_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_IsTableEnabled_result_success record   `hashWithSalt` f_IsTableEnabled_result_io record  
write_IsTableEnabled_result oprot record = do
  writeStructBegin oprot "IsTableEnabled_result"
  case f_IsTableEnabled_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_BOOL,0)
    writeBool oprot _v
    writeFieldEnd oprot}
  case f_IsTableEnabled_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_IsTableEnabled_result_fields iprot record = do
  (_,_t113,_id114) <- readFieldBegin iprot
  if _t113 == T_STOP then return record else
    case _id114 of 
      0 -> if _t113 == T_BOOL then do
        s <- readBool iprot
        read_IsTableEnabled_result_fields iprot record{f_IsTableEnabled_result_success=Just s}
        else do
          skip iprot _t113
          read_IsTableEnabled_result_fields iprot record
      1 -> if _t113 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_IsTableEnabled_result_fields iprot record{f_IsTableEnabled_result_io=Just s}
        else do
          skip iprot _t113
          read_IsTableEnabled_result_fields iprot record
      _ -> do
        skip iprot _t113
        readFieldEnd iprot
        read_IsTableEnabled_result_fields iprot record
read_IsTableEnabled_result iprot = do
  _ <- readStructBegin iprot
  record <- read_IsTableEnabled_result_fields iprot (IsTableEnabled_result{f_IsTableEnabled_result_success=Nothing,f_IsTableEnabled_result_io=Nothing})
  readStructEnd iprot
  return record
data Compact_args = Compact_args{f_Compact_args_tableNameOrRegionName :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable Compact_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Compact_args_tableNameOrRegionName record  
write_Compact_args oprot record = do
  writeStructBegin oprot "Compact_args"
  case f_Compact_args_tableNameOrRegionName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableNameOrRegionName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Compact_args_fields iprot record = do
  (_,_t118,_id119) <- readFieldBegin iprot
  if _t118 == T_STOP then return record else
    case _id119 of 
      1 -> if _t118 == T_STRING then do
        s <- readBinary iprot
        read_Compact_args_fields iprot record{f_Compact_args_tableNameOrRegionName=Just s}
        else do
          skip iprot _t118
          read_Compact_args_fields iprot record
      _ -> do
        skip iprot _t118
        readFieldEnd iprot
        read_Compact_args_fields iprot record
read_Compact_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Compact_args_fields iprot (Compact_args{f_Compact_args_tableNameOrRegionName=Nothing})
  readStructEnd iprot
  return record
data Compact_result = Compact_result{f_Compact_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable Compact_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Compact_result_io record  
write_Compact_result oprot record = do
  writeStructBegin oprot "Compact_result"
  case f_Compact_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Compact_result_fields iprot record = do
  (_,_t123,_id124) <- readFieldBegin iprot
  if _t123 == T_STOP then return record else
    case _id124 of 
      1 -> if _t123 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_Compact_result_fields iprot record{f_Compact_result_io=Just s}
        else do
          skip iprot _t123
          read_Compact_result_fields iprot record
      _ -> do
        skip iprot _t123
        readFieldEnd iprot
        read_Compact_result_fields iprot record
read_Compact_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Compact_result_fields iprot (Compact_result{f_Compact_result_io=Nothing})
  readStructEnd iprot
  return record
data MajorCompact_args = MajorCompact_args{f_MajorCompact_args_tableNameOrRegionName :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable MajorCompact_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_MajorCompact_args_tableNameOrRegionName record  
write_MajorCompact_args oprot record = do
  writeStructBegin oprot "MajorCompact_args"
  case f_MajorCompact_args_tableNameOrRegionName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableNameOrRegionName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MajorCompact_args_fields iprot record = do
  (_,_t128,_id129) <- readFieldBegin iprot
  if _t128 == T_STOP then return record else
    case _id129 of 
      1 -> if _t128 == T_STRING then do
        s <- readBinary iprot
        read_MajorCompact_args_fields iprot record{f_MajorCompact_args_tableNameOrRegionName=Just s}
        else do
          skip iprot _t128
          read_MajorCompact_args_fields iprot record
      _ -> do
        skip iprot _t128
        readFieldEnd iprot
        read_MajorCompact_args_fields iprot record
read_MajorCompact_args iprot = do
  _ <- readStructBegin iprot
  record <- read_MajorCompact_args_fields iprot (MajorCompact_args{f_MajorCompact_args_tableNameOrRegionName=Nothing})
  readStructEnd iprot
  return record
data MajorCompact_result = MajorCompact_result{f_MajorCompact_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable MajorCompact_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_MajorCompact_result_io record  
write_MajorCompact_result oprot record = do
  writeStructBegin oprot "MajorCompact_result"
  case f_MajorCompact_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MajorCompact_result_fields iprot record = do
  (_,_t133,_id134) <- readFieldBegin iprot
  if _t133 == T_STOP then return record else
    case _id134 of 
      1 -> if _t133 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_MajorCompact_result_fields iprot record{f_MajorCompact_result_io=Just s}
        else do
          skip iprot _t133
          read_MajorCompact_result_fields iprot record
      _ -> do
        skip iprot _t133
        readFieldEnd iprot
        read_MajorCompact_result_fields iprot record
read_MajorCompact_result iprot = do
  _ <- readStructBegin iprot
  record <- read_MajorCompact_result_fields iprot (MajorCompact_result{f_MajorCompact_result_io=Nothing})
  readStructEnd iprot
  return record
data GetTableNames_args = GetTableNames_args deriving (Show,Eq,Typeable)
instance Hashable GetTableNames_args where
  hashWithSalt salt record = salt  
write_GetTableNames_args oprot record = do
  writeStructBegin oprot "GetTableNames_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_GetTableNames_args_fields iprot record = do
  (_,_t138,_id139) <- readFieldBegin iprot
  if _t138 == T_STOP then return record else
    case _id139 of 
      _ -> do
        skip iprot _t138
        readFieldEnd iprot
        read_GetTableNames_args_fields iprot record
read_GetTableNames_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetTableNames_args_fields iprot (GetTableNames_args{})
  readStructEnd iprot
  return record
data GetTableNames_result = GetTableNames_result{f_GetTableNames_result_success :: Maybe (Vector.Vector ByteString),f_GetTableNames_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetTableNames_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetTableNames_result_success record   `hashWithSalt` f_GetTableNames_result_io record  
write_GetTableNames_result oprot record = do
  writeStructBegin oprot "GetTableNames_result"
  case f_GetTableNames_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter142 -> writeBinary oprot _viter142) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetTableNames_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetTableNames_result_fields iprot record = do
  (_,_t144,_id145) <- readFieldBegin iprot
  if _t144 == T_STOP then return record else
    case _id145 of 
      0 -> if _t144 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype149,_size146) <- readListBegin iprot; f _size146})
        read_GetTableNames_result_fields iprot record{f_GetTableNames_result_success=Just s}
        else do
          skip iprot _t144
          read_GetTableNames_result_fields iprot record
      1 -> if _t144 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetTableNames_result_fields iprot record{f_GetTableNames_result_io=Just s}
        else do
          skip iprot _t144
          read_GetTableNames_result_fields iprot record
      _ -> do
        skip iprot _t144
        readFieldEnd iprot
        read_GetTableNames_result_fields iprot record
read_GetTableNames_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetTableNames_result_fields iprot (GetTableNames_result{f_GetTableNames_result_success=Nothing,f_GetTableNames_result_io=Nothing})
  readStructEnd iprot
  return record
data GetColumnDescriptors_args = GetColumnDescriptors_args{f_GetColumnDescriptors_args_tableName :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable GetColumnDescriptors_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetColumnDescriptors_args_tableName record  
write_GetColumnDescriptors_args oprot record = do
  writeStructBegin oprot "GetColumnDescriptors_args"
  case f_GetColumnDescriptors_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetColumnDescriptors_args_fields iprot record = do
  (_,_t154,_id155) <- readFieldBegin iprot
  if _t154 == T_STOP then return record else
    case _id155 of 
      1 -> if _t154 == T_STRING then do
        s <- readBinary iprot
        read_GetColumnDescriptors_args_fields iprot record{f_GetColumnDescriptors_args_tableName=Just s}
        else do
          skip iprot _t154
          read_GetColumnDescriptors_args_fields iprot record
      _ -> do
        skip iprot _t154
        readFieldEnd iprot
        read_GetColumnDescriptors_args_fields iprot record
read_GetColumnDescriptors_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetColumnDescriptors_args_fields iprot (GetColumnDescriptors_args{f_GetColumnDescriptors_args_tableName=Nothing})
  readStructEnd iprot
  return record
data GetColumnDescriptors_result = GetColumnDescriptors_result{f_GetColumnDescriptors_result_success :: Maybe (Map.HashMap ByteString ColumnDescriptor),f_GetColumnDescriptors_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetColumnDescriptors_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetColumnDescriptors_result_success record   `hashWithSalt` f_GetColumnDescriptors_result_io record  
write_GetColumnDescriptors_result oprot record = do
  writeStructBegin oprot "GetColumnDescriptors_result"
  case f_GetColumnDescriptors_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_MAP,0)
    (let {f [] = return (); f ((_kiter158,_viter159):t) = do {do {writeBinary oprot _kiter158;write_ColumnDescriptor oprot _viter159};f t}} in do {writeMapBegin oprot (T_STRING,T_STRUCT,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  case f_GetColumnDescriptors_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetColumnDescriptors_result_fields iprot record = do
  (_,_t161,_id162) <- readFieldBegin iprot
  if _t161 == T_STOP then return record else
    case _id162 of 
      0 -> if _t161 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- (read_ColumnDescriptor iprot);r <- f (n-1); return $ (k,v):r}} in do {(_ktype164,_vtype165,_size163) <- readMapBegin iprot; l <- f _size163; return $ Map.fromList l})
        read_GetColumnDescriptors_result_fields iprot record{f_GetColumnDescriptors_result_success=Just s}
        else do
          skip iprot _t161
          read_GetColumnDescriptors_result_fields iprot record
      1 -> if _t161 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetColumnDescriptors_result_fields iprot record{f_GetColumnDescriptors_result_io=Just s}
        else do
          skip iprot _t161
          read_GetColumnDescriptors_result_fields iprot record
      _ -> do
        skip iprot _t161
        readFieldEnd iprot
        read_GetColumnDescriptors_result_fields iprot record
read_GetColumnDescriptors_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetColumnDescriptors_result_fields iprot (GetColumnDescriptors_result{f_GetColumnDescriptors_result_success=Nothing,f_GetColumnDescriptors_result_io=Nothing})
  readStructEnd iprot
  return record
data GetTableRegions_args = GetTableRegions_args{f_GetTableRegions_args_tableName :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable GetTableRegions_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetTableRegions_args_tableName record  
write_GetTableRegions_args oprot record = do
  writeStructBegin oprot "GetTableRegions_args"
  case f_GetTableRegions_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetTableRegions_args_fields iprot record = do
  (_,_t171,_id172) <- readFieldBegin iprot
  if _t171 == T_STOP then return record else
    case _id172 of 
      1 -> if _t171 == T_STRING then do
        s <- readBinary iprot
        read_GetTableRegions_args_fields iprot record{f_GetTableRegions_args_tableName=Just s}
        else do
          skip iprot _t171
          read_GetTableRegions_args_fields iprot record
      _ -> do
        skip iprot _t171
        readFieldEnd iprot
        read_GetTableRegions_args_fields iprot record
read_GetTableRegions_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetTableRegions_args_fields iprot (GetTableRegions_args{f_GetTableRegions_args_tableName=Nothing})
  readStructEnd iprot
  return record
data GetTableRegions_result = GetTableRegions_result{f_GetTableRegions_result_success :: Maybe (Vector.Vector TRegionInfo),f_GetTableRegions_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetTableRegions_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetTableRegions_result_success record   `hashWithSalt` f_GetTableRegions_result_io record  
write_GetTableRegions_result oprot record = do
  writeStructBegin oprot "GetTableRegions_result"
  case f_GetTableRegions_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter175 -> write_TRegionInfo oprot _viter175) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetTableRegions_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetTableRegions_result_fields iprot record = do
  (_,_t177,_id178) <- readFieldBegin iprot
  if _t177 == T_STOP then return record else
    case _id178 of 
      0 -> if _t177 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TRegionInfo iprot)) in do {(_etype182,_size179) <- readListBegin iprot; f _size179})
        read_GetTableRegions_result_fields iprot record{f_GetTableRegions_result_success=Just s}
        else do
          skip iprot _t177
          read_GetTableRegions_result_fields iprot record
      1 -> if _t177 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetTableRegions_result_fields iprot record{f_GetTableRegions_result_io=Just s}
        else do
          skip iprot _t177
          read_GetTableRegions_result_fields iprot record
      _ -> do
        skip iprot _t177
        readFieldEnd iprot
        read_GetTableRegions_result_fields iprot record
read_GetTableRegions_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetTableRegions_result_fields iprot (GetTableRegions_result{f_GetTableRegions_result_success=Nothing,f_GetTableRegions_result_io=Nothing})
  readStructEnd iprot
  return record
data CreateTable_args = CreateTable_args{f_CreateTable_args_tableName :: Maybe ByteString,f_CreateTable_args_columnFamilies :: Maybe (Vector.Vector ColumnDescriptor)} deriving (Show,Eq,Typeable)
instance Hashable CreateTable_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateTable_args_tableName record   `hashWithSalt` f_CreateTable_args_columnFamilies record  
write_CreateTable_args oprot record = do
  writeStructBegin oprot "CreateTable_args"
  case f_CreateTable_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_CreateTable_args_columnFamilies record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columnFamilies",T_LIST,2)
    (let f = Vector.mapM_ (\_viter186 -> write_ColumnDescriptor oprot _viter186) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateTable_args_fields iprot record = do
  (_,_t188,_id189) <- readFieldBegin iprot
  if _t188 == T_STOP then return record else
    case _id189 of 
      1 -> if _t188 == T_STRING then do
        s <- readBinary iprot
        read_CreateTable_args_fields iprot record{f_CreateTable_args_tableName=Just s}
        else do
          skip iprot _t188
          read_CreateTable_args_fields iprot record
      2 -> if _t188 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_ColumnDescriptor iprot)) in do {(_etype193,_size190) <- readListBegin iprot; f _size190})
        read_CreateTable_args_fields iprot record{f_CreateTable_args_columnFamilies=Just s}
        else do
          skip iprot _t188
          read_CreateTable_args_fields iprot record
      _ -> do
        skip iprot _t188
        readFieldEnd iprot
        read_CreateTable_args_fields iprot record
read_CreateTable_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateTable_args_fields iprot (CreateTable_args{f_CreateTable_args_tableName=Nothing,f_CreateTable_args_columnFamilies=Nothing})
  readStructEnd iprot
  return record
data CreateTable_result = CreateTable_result{f_CreateTable_result_io :: Maybe IOError,f_CreateTable_result_ia :: Maybe IllegalArgument,f_CreateTable_result_exist :: Maybe AlreadyExists} deriving (Show,Eq,Typeable)
instance Hashable CreateTable_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateTable_result_io record   `hashWithSalt` f_CreateTable_result_ia record   `hashWithSalt` f_CreateTable_result_exist record  
write_CreateTable_result oprot record = do
  writeStructBegin oprot "CreateTable_result"
  case f_CreateTable_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  case f_CreateTable_result_ia record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ia",T_STRUCT,2)
    write_IllegalArgument oprot _v
    writeFieldEnd oprot}
  case f_CreateTable_result_exist record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("exist",T_STRUCT,3)
    write_AlreadyExists oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateTable_result_fields iprot record = do
  (_,_t198,_id199) <- readFieldBegin iprot
  if _t198 == T_STOP then return record else
    case _id199 of 
      1 -> if _t198 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_CreateTable_result_fields iprot record{f_CreateTable_result_io=Just s}
        else do
          skip iprot _t198
          read_CreateTable_result_fields iprot record
      2 -> if _t198 == T_STRUCT then do
        s <- (read_IllegalArgument iprot)
        read_CreateTable_result_fields iprot record{f_CreateTable_result_ia=Just s}
        else do
          skip iprot _t198
          read_CreateTable_result_fields iprot record
      3 -> if _t198 == T_STRUCT then do
        s <- (read_AlreadyExists iprot)
        read_CreateTable_result_fields iprot record{f_CreateTable_result_exist=Just s}
        else do
          skip iprot _t198
          read_CreateTable_result_fields iprot record
      _ -> do
        skip iprot _t198
        readFieldEnd iprot
        read_CreateTable_result_fields iprot record
read_CreateTable_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateTable_result_fields iprot (CreateTable_result{f_CreateTable_result_io=Nothing,f_CreateTable_result_ia=Nothing,f_CreateTable_result_exist=Nothing})
  readStructEnd iprot
  return record
data DeleteTable_args = DeleteTable_args{f_DeleteTable_args_tableName :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable DeleteTable_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteTable_args_tableName record  
write_DeleteTable_args oprot record = do
  writeStructBegin oprot "DeleteTable_args"
  case f_DeleteTable_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteTable_args_fields iprot record = do
  (_,_t203,_id204) <- readFieldBegin iprot
  if _t203 == T_STOP then return record else
    case _id204 of 
      1 -> if _t203 == T_STRING then do
        s <- readBinary iprot
        read_DeleteTable_args_fields iprot record{f_DeleteTable_args_tableName=Just s}
        else do
          skip iprot _t203
          read_DeleteTable_args_fields iprot record
      _ -> do
        skip iprot _t203
        readFieldEnd iprot
        read_DeleteTable_args_fields iprot record
read_DeleteTable_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteTable_args_fields iprot (DeleteTable_args{f_DeleteTable_args_tableName=Nothing})
  readStructEnd iprot
  return record
data DeleteTable_result = DeleteTable_result{f_DeleteTable_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable DeleteTable_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteTable_result_io record  
write_DeleteTable_result oprot record = do
  writeStructBegin oprot "DeleteTable_result"
  case f_DeleteTable_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteTable_result_fields iprot record = do
  (_,_t208,_id209) <- readFieldBegin iprot
  if _t208 == T_STOP then return record else
    case _id209 of 
      1 -> if _t208 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_DeleteTable_result_fields iprot record{f_DeleteTable_result_io=Just s}
        else do
          skip iprot _t208
          read_DeleteTable_result_fields iprot record
      _ -> do
        skip iprot _t208
        readFieldEnd iprot
        read_DeleteTable_result_fields iprot record
read_DeleteTable_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteTable_result_fields iprot (DeleteTable_result{f_DeleteTable_result_io=Nothing})
  readStructEnd iprot
  return record
data Get_args = Get_args{f_Get_args_tableName :: Maybe ByteString,f_Get_args_row :: Maybe ByteString,f_Get_args_column :: Maybe ByteString,f_Get_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable Get_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Get_args_tableName record   `hashWithSalt` f_Get_args_row record   `hashWithSalt` f_Get_args_column record   `hashWithSalt` f_Get_args_attributes record  
write_Get_args oprot record = do
  writeStructBegin oprot "Get_args"
  case f_Get_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Get_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Get_args_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Get_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter212,_viter213):t) = do {do {writeBinary oprot _kiter212;writeBinary oprot _viter213};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Get_args_fields iprot record = do
  (_,_t215,_id216) <- readFieldBegin iprot
  if _t215 == T_STOP then return record else
    case _id216 of 
      1 -> if _t215 == T_STRING then do
        s <- readBinary iprot
        read_Get_args_fields iprot record{f_Get_args_tableName=Just s}
        else do
          skip iprot _t215
          read_Get_args_fields iprot record
      2 -> if _t215 == T_STRING then do
        s <- readBinary iprot
        read_Get_args_fields iprot record{f_Get_args_row=Just s}
        else do
          skip iprot _t215
          read_Get_args_fields iprot record
      3 -> if _t215 == T_STRING then do
        s <- readBinary iprot
        read_Get_args_fields iprot record{f_Get_args_column=Just s}
        else do
          skip iprot _t215
          read_Get_args_fields iprot record
      4 -> if _t215 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype218,_vtype219,_size217) <- readMapBegin iprot; l <- f _size217; return $ Map.fromList l})
        read_Get_args_fields iprot record{f_Get_args_attributes=Just s}
        else do
          skip iprot _t215
          read_Get_args_fields iprot record
      _ -> do
        skip iprot _t215
        readFieldEnd iprot
        read_Get_args_fields iprot record
read_Get_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Get_args_fields iprot (Get_args{f_Get_args_tableName=Nothing,f_Get_args_row=Nothing,f_Get_args_column=Nothing,f_Get_args_attributes=Nothing})
  readStructEnd iprot
  return record
data Get_result = Get_result{f_Get_result_success :: Maybe (Vector.Vector TCell),f_Get_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable Get_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Get_result_success record   `hashWithSalt` f_Get_result_io record  
write_Get_result oprot record = do
  writeStructBegin oprot "Get_result"
  case f_Get_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter224 -> write_TCell oprot _viter224) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Get_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Get_result_fields iprot record = do
  (_,_t226,_id227) <- readFieldBegin iprot
  if _t226 == T_STOP then return record else
    case _id227 of 
      0 -> if _t226 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TCell iprot)) in do {(_etype231,_size228) <- readListBegin iprot; f _size228})
        read_Get_result_fields iprot record{f_Get_result_success=Just s}
        else do
          skip iprot _t226
          read_Get_result_fields iprot record
      1 -> if _t226 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_Get_result_fields iprot record{f_Get_result_io=Just s}
        else do
          skip iprot _t226
          read_Get_result_fields iprot record
      _ -> do
        skip iprot _t226
        readFieldEnd iprot
        read_Get_result_fields iprot record
read_Get_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Get_result_fields iprot (Get_result{f_Get_result_success=Nothing,f_Get_result_io=Nothing})
  readStructEnd iprot
  return record
data GetVer_args = GetVer_args{f_GetVer_args_tableName :: Maybe ByteString,f_GetVer_args_row :: Maybe ByteString,f_GetVer_args_column :: Maybe ByteString,f_GetVer_args_numVersions :: Maybe Int32,f_GetVer_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable GetVer_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetVer_args_tableName record   `hashWithSalt` f_GetVer_args_row record   `hashWithSalt` f_GetVer_args_column record   `hashWithSalt` f_GetVer_args_numVersions record   `hashWithSalt` f_GetVer_args_attributes record  
write_GetVer_args oprot record = do
  writeStructBegin oprot "GetVer_args"
  case f_GetVer_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetVer_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetVer_args_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetVer_args_numVersions record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("numVersions",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_GetVer_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,5)
    (let {f [] = return (); f ((_kiter235,_viter236):t) = do {do {writeBinary oprot _kiter235;writeBinary oprot _viter236};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetVer_args_fields iprot record = do
  (_,_t238,_id239) <- readFieldBegin iprot
  if _t238 == T_STOP then return record else
    case _id239 of 
      1 -> if _t238 == T_STRING then do
        s <- readBinary iprot
        read_GetVer_args_fields iprot record{f_GetVer_args_tableName=Just s}
        else do
          skip iprot _t238
          read_GetVer_args_fields iprot record
      2 -> if _t238 == T_STRING then do
        s <- readBinary iprot
        read_GetVer_args_fields iprot record{f_GetVer_args_row=Just s}
        else do
          skip iprot _t238
          read_GetVer_args_fields iprot record
      3 -> if _t238 == T_STRING then do
        s <- readBinary iprot
        read_GetVer_args_fields iprot record{f_GetVer_args_column=Just s}
        else do
          skip iprot _t238
          read_GetVer_args_fields iprot record
      4 -> if _t238 == T_I32 then do
        s <- readI32 iprot
        read_GetVer_args_fields iprot record{f_GetVer_args_numVersions=Just s}
        else do
          skip iprot _t238
          read_GetVer_args_fields iprot record
      5 -> if _t238 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype241,_vtype242,_size240) <- readMapBegin iprot; l <- f _size240; return $ Map.fromList l})
        read_GetVer_args_fields iprot record{f_GetVer_args_attributes=Just s}
        else do
          skip iprot _t238
          read_GetVer_args_fields iprot record
      _ -> do
        skip iprot _t238
        readFieldEnd iprot
        read_GetVer_args_fields iprot record
read_GetVer_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetVer_args_fields iprot (GetVer_args{f_GetVer_args_tableName=Nothing,f_GetVer_args_row=Nothing,f_GetVer_args_column=Nothing,f_GetVer_args_numVersions=Nothing,f_GetVer_args_attributes=Nothing})
  readStructEnd iprot
  return record
data GetVer_result = GetVer_result{f_GetVer_result_success :: Maybe (Vector.Vector TCell),f_GetVer_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetVer_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetVer_result_success record   `hashWithSalt` f_GetVer_result_io record  
write_GetVer_result oprot record = do
  writeStructBegin oprot "GetVer_result"
  case f_GetVer_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter247 -> write_TCell oprot _viter247) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetVer_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetVer_result_fields iprot record = do
  (_,_t249,_id250) <- readFieldBegin iprot
  if _t249 == T_STOP then return record else
    case _id250 of 
      0 -> if _t249 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TCell iprot)) in do {(_etype254,_size251) <- readListBegin iprot; f _size251})
        read_GetVer_result_fields iprot record{f_GetVer_result_success=Just s}
        else do
          skip iprot _t249
          read_GetVer_result_fields iprot record
      1 -> if _t249 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetVer_result_fields iprot record{f_GetVer_result_io=Just s}
        else do
          skip iprot _t249
          read_GetVer_result_fields iprot record
      _ -> do
        skip iprot _t249
        readFieldEnd iprot
        read_GetVer_result_fields iprot record
read_GetVer_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetVer_result_fields iprot (GetVer_result{f_GetVer_result_success=Nothing,f_GetVer_result_io=Nothing})
  readStructEnd iprot
  return record
data GetVerTs_args = GetVerTs_args{f_GetVerTs_args_tableName :: Maybe ByteString,f_GetVerTs_args_row :: Maybe ByteString,f_GetVerTs_args_column :: Maybe ByteString,f_GetVerTs_args_timestamp :: Maybe Int64,f_GetVerTs_args_numVersions :: Maybe Int32,f_GetVerTs_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable GetVerTs_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetVerTs_args_tableName record   `hashWithSalt` f_GetVerTs_args_row record   `hashWithSalt` f_GetVerTs_args_column record   `hashWithSalt` f_GetVerTs_args_timestamp record   `hashWithSalt` f_GetVerTs_args_numVersions record   `hashWithSalt` f_GetVerTs_args_attributes record  
write_GetVerTs_args oprot record = do
  writeStructBegin oprot "GetVerTs_args"
  case f_GetVerTs_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetVerTs_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetVerTs_args_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetVerTs_args_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,4)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_GetVerTs_args_numVersions record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("numVersions",T_I32,5)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_GetVerTs_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,6)
    (let {f [] = return (); f ((_kiter258,_viter259):t) = do {do {writeBinary oprot _kiter258;writeBinary oprot _viter259};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetVerTs_args_fields iprot record = do
  (_,_t261,_id262) <- readFieldBegin iprot
  if _t261 == T_STOP then return record else
    case _id262 of 
      1 -> if _t261 == T_STRING then do
        s <- readBinary iprot
        read_GetVerTs_args_fields iprot record{f_GetVerTs_args_tableName=Just s}
        else do
          skip iprot _t261
          read_GetVerTs_args_fields iprot record
      2 -> if _t261 == T_STRING then do
        s <- readBinary iprot
        read_GetVerTs_args_fields iprot record{f_GetVerTs_args_row=Just s}
        else do
          skip iprot _t261
          read_GetVerTs_args_fields iprot record
      3 -> if _t261 == T_STRING then do
        s <- readBinary iprot
        read_GetVerTs_args_fields iprot record{f_GetVerTs_args_column=Just s}
        else do
          skip iprot _t261
          read_GetVerTs_args_fields iprot record
      4 -> if _t261 == T_I64 then do
        s <- readI64 iprot
        read_GetVerTs_args_fields iprot record{f_GetVerTs_args_timestamp=Just s}
        else do
          skip iprot _t261
          read_GetVerTs_args_fields iprot record
      5 -> if _t261 == T_I32 then do
        s <- readI32 iprot
        read_GetVerTs_args_fields iprot record{f_GetVerTs_args_numVersions=Just s}
        else do
          skip iprot _t261
          read_GetVerTs_args_fields iprot record
      6 -> if _t261 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype264,_vtype265,_size263) <- readMapBegin iprot; l <- f _size263; return $ Map.fromList l})
        read_GetVerTs_args_fields iprot record{f_GetVerTs_args_attributes=Just s}
        else do
          skip iprot _t261
          read_GetVerTs_args_fields iprot record
      _ -> do
        skip iprot _t261
        readFieldEnd iprot
        read_GetVerTs_args_fields iprot record
read_GetVerTs_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetVerTs_args_fields iprot (GetVerTs_args{f_GetVerTs_args_tableName=Nothing,f_GetVerTs_args_row=Nothing,f_GetVerTs_args_column=Nothing,f_GetVerTs_args_timestamp=Nothing,f_GetVerTs_args_numVersions=Nothing,f_GetVerTs_args_attributes=Nothing})
  readStructEnd iprot
  return record
data GetVerTs_result = GetVerTs_result{f_GetVerTs_result_success :: Maybe (Vector.Vector TCell),f_GetVerTs_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetVerTs_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetVerTs_result_success record   `hashWithSalt` f_GetVerTs_result_io record  
write_GetVerTs_result oprot record = do
  writeStructBegin oprot "GetVerTs_result"
  case f_GetVerTs_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter270 -> write_TCell oprot _viter270) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetVerTs_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetVerTs_result_fields iprot record = do
  (_,_t272,_id273) <- readFieldBegin iprot
  if _t272 == T_STOP then return record else
    case _id273 of 
      0 -> if _t272 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TCell iprot)) in do {(_etype277,_size274) <- readListBegin iprot; f _size274})
        read_GetVerTs_result_fields iprot record{f_GetVerTs_result_success=Just s}
        else do
          skip iprot _t272
          read_GetVerTs_result_fields iprot record
      1 -> if _t272 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetVerTs_result_fields iprot record{f_GetVerTs_result_io=Just s}
        else do
          skip iprot _t272
          read_GetVerTs_result_fields iprot record
      _ -> do
        skip iprot _t272
        readFieldEnd iprot
        read_GetVerTs_result_fields iprot record
read_GetVerTs_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetVerTs_result_fields iprot (GetVerTs_result{f_GetVerTs_result_success=Nothing,f_GetVerTs_result_io=Nothing})
  readStructEnd iprot
  return record
data GetRow_args = GetRow_args{f_GetRow_args_tableName :: Maybe ByteString,f_GetRow_args_row :: Maybe ByteString,f_GetRow_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable GetRow_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRow_args_tableName record   `hashWithSalt` f_GetRow_args_row record   `hashWithSalt` f_GetRow_args_attributes record  
write_GetRow_args oprot record = do
  writeStructBegin oprot "GetRow_args"
  case f_GetRow_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRow_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRow_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,3)
    (let {f [] = return (); f ((_kiter281,_viter282):t) = do {do {writeBinary oprot _kiter281;writeBinary oprot _viter282};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRow_args_fields iprot record = do
  (_,_t284,_id285) <- readFieldBegin iprot
  if _t284 == T_STOP then return record else
    case _id285 of 
      1 -> if _t284 == T_STRING then do
        s <- readBinary iprot
        read_GetRow_args_fields iprot record{f_GetRow_args_tableName=Just s}
        else do
          skip iprot _t284
          read_GetRow_args_fields iprot record
      2 -> if _t284 == T_STRING then do
        s <- readBinary iprot
        read_GetRow_args_fields iprot record{f_GetRow_args_row=Just s}
        else do
          skip iprot _t284
          read_GetRow_args_fields iprot record
      3 -> if _t284 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype287,_vtype288,_size286) <- readMapBegin iprot; l <- f _size286; return $ Map.fromList l})
        read_GetRow_args_fields iprot record{f_GetRow_args_attributes=Just s}
        else do
          skip iprot _t284
          read_GetRow_args_fields iprot record
      _ -> do
        skip iprot _t284
        readFieldEnd iprot
        read_GetRow_args_fields iprot record
read_GetRow_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRow_args_fields iprot (GetRow_args{f_GetRow_args_tableName=Nothing,f_GetRow_args_row=Nothing,f_GetRow_args_attributes=Nothing})
  readStructEnd iprot
  return record
data GetRow_result = GetRow_result{f_GetRow_result_success :: Maybe (Vector.Vector TRowResult),f_GetRow_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetRow_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRow_result_success record   `hashWithSalt` f_GetRow_result_io record  
write_GetRow_result oprot record = do
  writeStructBegin oprot "GetRow_result"
  case f_GetRow_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter293 -> write_TRowResult oprot _viter293) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRow_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRow_result_fields iprot record = do
  (_,_t295,_id296) <- readFieldBegin iprot
  if _t295 == T_STOP then return record else
    case _id296 of 
      0 -> if _t295 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TRowResult iprot)) in do {(_etype300,_size297) <- readListBegin iprot; f _size297})
        read_GetRow_result_fields iprot record{f_GetRow_result_success=Just s}
        else do
          skip iprot _t295
          read_GetRow_result_fields iprot record
      1 -> if _t295 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetRow_result_fields iprot record{f_GetRow_result_io=Just s}
        else do
          skip iprot _t295
          read_GetRow_result_fields iprot record
      _ -> do
        skip iprot _t295
        readFieldEnd iprot
        read_GetRow_result_fields iprot record
read_GetRow_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRow_result_fields iprot (GetRow_result{f_GetRow_result_success=Nothing,f_GetRow_result_io=Nothing})
  readStructEnd iprot
  return record
data GetRowWithColumns_args = GetRowWithColumns_args{f_GetRowWithColumns_args_tableName :: Maybe ByteString,f_GetRowWithColumns_args_row :: Maybe ByteString,f_GetRowWithColumns_args_columns :: Maybe (Vector.Vector ByteString),f_GetRowWithColumns_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable GetRowWithColumns_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowWithColumns_args_tableName record   `hashWithSalt` f_GetRowWithColumns_args_row record   `hashWithSalt` f_GetRowWithColumns_args_columns record   `hashWithSalt` f_GetRowWithColumns_args_attributes record  
write_GetRowWithColumns_args oprot record = do
  writeStructBegin oprot "GetRowWithColumns_args"
  case f_GetRowWithColumns_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRowWithColumns_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRowWithColumns_args_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,3)
    (let f = Vector.mapM_ (\_viter304 -> writeBinary oprot _viter304) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowWithColumns_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter305,_viter306):t) = do {do {writeBinary oprot _kiter305;writeBinary oprot _viter306};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowWithColumns_args_fields iprot record = do
  (_,_t308,_id309) <- readFieldBegin iprot
  if _t308 == T_STOP then return record else
    case _id309 of 
      1 -> if _t308 == T_STRING then do
        s <- readBinary iprot
        read_GetRowWithColumns_args_fields iprot record{f_GetRowWithColumns_args_tableName=Just s}
        else do
          skip iprot _t308
          read_GetRowWithColumns_args_fields iprot record
      2 -> if _t308 == T_STRING then do
        s <- readBinary iprot
        read_GetRowWithColumns_args_fields iprot record{f_GetRowWithColumns_args_row=Just s}
        else do
          skip iprot _t308
          read_GetRowWithColumns_args_fields iprot record
      3 -> if _t308 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype313,_size310) <- readListBegin iprot; f _size310})
        read_GetRowWithColumns_args_fields iprot record{f_GetRowWithColumns_args_columns=Just s}
        else do
          skip iprot _t308
          read_GetRowWithColumns_args_fields iprot record
      4 -> if _t308 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype316,_vtype317,_size315) <- readMapBegin iprot; l <- f _size315; return $ Map.fromList l})
        read_GetRowWithColumns_args_fields iprot record{f_GetRowWithColumns_args_attributes=Just s}
        else do
          skip iprot _t308
          read_GetRowWithColumns_args_fields iprot record
      _ -> do
        skip iprot _t308
        readFieldEnd iprot
        read_GetRowWithColumns_args_fields iprot record
read_GetRowWithColumns_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowWithColumns_args_fields iprot (GetRowWithColumns_args{f_GetRowWithColumns_args_tableName=Nothing,f_GetRowWithColumns_args_row=Nothing,f_GetRowWithColumns_args_columns=Nothing,f_GetRowWithColumns_args_attributes=Nothing})
  readStructEnd iprot
  return record
data GetRowWithColumns_result = GetRowWithColumns_result{f_GetRowWithColumns_result_success :: Maybe (Vector.Vector TRowResult),f_GetRowWithColumns_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetRowWithColumns_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowWithColumns_result_success record   `hashWithSalt` f_GetRowWithColumns_result_io record  
write_GetRowWithColumns_result oprot record = do
  writeStructBegin oprot "GetRowWithColumns_result"
  case f_GetRowWithColumns_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter322 -> write_TRowResult oprot _viter322) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowWithColumns_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowWithColumns_result_fields iprot record = do
  (_,_t324,_id325) <- readFieldBegin iprot
  if _t324 == T_STOP then return record else
    case _id325 of 
      0 -> if _t324 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TRowResult iprot)) in do {(_etype329,_size326) <- readListBegin iprot; f _size326})
        read_GetRowWithColumns_result_fields iprot record{f_GetRowWithColumns_result_success=Just s}
        else do
          skip iprot _t324
          read_GetRowWithColumns_result_fields iprot record
      1 -> if _t324 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetRowWithColumns_result_fields iprot record{f_GetRowWithColumns_result_io=Just s}
        else do
          skip iprot _t324
          read_GetRowWithColumns_result_fields iprot record
      _ -> do
        skip iprot _t324
        readFieldEnd iprot
        read_GetRowWithColumns_result_fields iprot record
read_GetRowWithColumns_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowWithColumns_result_fields iprot (GetRowWithColumns_result{f_GetRowWithColumns_result_success=Nothing,f_GetRowWithColumns_result_io=Nothing})
  readStructEnd iprot
  return record
data GetRowTs_args = GetRowTs_args{f_GetRowTs_args_tableName :: Maybe ByteString,f_GetRowTs_args_row :: Maybe ByteString,f_GetRowTs_args_timestamp :: Maybe Int64,f_GetRowTs_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable GetRowTs_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowTs_args_tableName record   `hashWithSalt` f_GetRowTs_args_row record   `hashWithSalt` f_GetRowTs_args_timestamp record   `hashWithSalt` f_GetRowTs_args_attributes record  
write_GetRowTs_args oprot record = do
  writeStructBegin oprot "GetRowTs_args"
  case f_GetRowTs_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRowTs_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRowTs_args_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_GetRowTs_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter333,_viter334):t) = do {do {writeBinary oprot _kiter333;writeBinary oprot _viter334};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowTs_args_fields iprot record = do
  (_,_t336,_id337) <- readFieldBegin iprot
  if _t336 == T_STOP then return record else
    case _id337 of 
      1 -> if _t336 == T_STRING then do
        s <- readBinary iprot
        read_GetRowTs_args_fields iprot record{f_GetRowTs_args_tableName=Just s}
        else do
          skip iprot _t336
          read_GetRowTs_args_fields iprot record
      2 -> if _t336 == T_STRING then do
        s <- readBinary iprot
        read_GetRowTs_args_fields iprot record{f_GetRowTs_args_row=Just s}
        else do
          skip iprot _t336
          read_GetRowTs_args_fields iprot record
      3 -> if _t336 == T_I64 then do
        s <- readI64 iprot
        read_GetRowTs_args_fields iprot record{f_GetRowTs_args_timestamp=Just s}
        else do
          skip iprot _t336
          read_GetRowTs_args_fields iprot record
      4 -> if _t336 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype339,_vtype340,_size338) <- readMapBegin iprot; l <- f _size338; return $ Map.fromList l})
        read_GetRowTs_args_fields iprot record{f_GetRowTs_args_attributes=Just s}
        else do
          skip iprot _t336
          read_GetRowTs_args_fields iprot record
      _ -> do
        skip iprot _t336
        readFieldEnd iprot
        read_GetRowTs_args_fields iprot record
read_GetRowTs_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowTs_args_fields iprot (GetRowTs_args{f_GetRowTs_args_tableName=Nothing,f_GetRowTs_args_row=Nothing,f_GetRowTs_args_timestamp=Nothing,f_GetRowTs_args_attributes=Nothing})
  readStructEnd iprot
  return record
data GetRowTs_result = GetRowTs_result{f_GetRowTs_result_success :: Maybe (Vector.Vector TRowResult),f_GetRowTs_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetRowTs_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowTs_result_success record   `hashWithSalt` f_GetRowTs_result_io record  
write_GetRowTs_result oprot record = do
  writeStructBegin oprot "GetRowTs_result"
  case f_GetRowTs_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter345 -> write_TRowResult oprot _viter345) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowTs_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowTs_result_fields iprot record = do
  (_,_t347,_id348) <- readFieldBegin iprot
  if _t347 == T_STOP then return record else
    case _id348 of 
      0 -> if _t347 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TRowResult iprot)) in do {(_etype352,_size349) <- readListBegin iprot; f _size349})
        read_GetRowTs_result_fields iprot record{f_GetRowTs_result_success=Just s}
        else do
          skip iprot _t347
          read_GetRowTs_result_fields iprot record
      1 -> if _t347 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetRowTs_result_fields iprot record{f_GetRowTs_result_io=Just s}
        else do
          skip iprot _t347
          read_GetRowTs_result_fields iprot record
      _ -> do
        skip iprot _t347
        readFieldEnd iprot
        read_GetRowTs_result_fields iprot record
read_GetRowTs_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowTs_result_fields iprot (GetRowTs_result{f_GetRowTs_result_success=Nothing,f_GetRowTs_result_io=Nothing})
  readStructEnd iprot
  return record
data GetRowWithColumnsTs_args = GetRowWithColumnsTs_args{f_GetRowWithColumnsTs_args_tableName :: Maybe ByteString,f_GetRowWithColumnsTs_args_row :: Maybe ByteString,f_GetRowWithColumnsTs_args_columns :: Maybe (Vector.Vector ByteString),f_GetRowWithColumnsTs_args_timestamp :: Maybe Int64,f_GetRowWithColumnsTs_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable GetRowWithColumnsTs_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowWithColumnsTs_args_tableName record   `hashWithSalt` f_GetRowWithColumnsTs_args_row record   `hashWithSalt` f_GetRowWithColumnsTs_args_columns record   `hashWithSalt` f_GetRowWithColumnsTs_args_timestamp record   `hashWithSalt` f_GetRowWithColumnsTs_args_attributes record  
write_GetRowWithColumnsTs_args oprot record = do
  writeStructBegin oprot "GetRowWithColumnsTs_args"
  case f_GetRowWithColumnsTs_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRowWithColumnsTs_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRowWithColumnsTs_args_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,3)
    (let f = Vector.mapM_ (\_viter356 -> writeBinary oprot _viter356) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowWithColumnsTs_args_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,4)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_GetRowWithColumnsTs_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,5)
    (let {f [] = return (); f ((_kiter357,_viter358):t) = do {do {writeBinary oprot _kiter357;writeBinary oprot _viter358};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowWithColumnsTs_args_fields iprot record = do
  (_,_t360,_id361) <- readFieldBegin iprot
  if _t360 == T_STOP then return record else
    case _id361 of 
      1 -> if _t360 == T_STRING then do
        s <- readBinary iprot
        read_GetRowWithColumnsTs_args_fields iprot record{f_GetRowWithColumnsTs_args_tableName=Just s}
        else do
          skip iprot _t360
          read_GetRowWithColumnsTs_args_fields iprot record
      2 -> if _t360 == T_STRING then do
        s <- readBinary iprot
        read_GetRowWithColumnsTs_args_fields iprot record{f_GetRowWithColumnsTs_args_row=Just s}
        else do
          skip iprot _t360
          read_GetRowWithColumnsTs_args_fields iprot record
      3 -> if _t360 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype365,_size362) <- readListBegin iprot; f _size362})
        read_GetRowWithColumnsTs_args_fields iprot record{f_GetRowWithColumnsTs_args_columns=Just s}
        else do
          skip iprot _t360
          read_GetRowWithColumnsTs_args_fields iprot record
      4 -> if _t360 == T_I64 then do
        s <- readI64 iprot
        read_GetRowWithColumnsTs_args_fields iprot record{f_GetRowWithColumnsTs_args_timestamp=Just s}
        else do
          skip iprot _t360
          read_GetRowWithColumnsTs_args_fields iprot record
      5 -> if _t360 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype368,_vtype369,_size367) <- readMapBegin iprot; l <- f _size367; return $ Map.fromList l})
        read_GetRowWithColumnsTs_args_fields iprot record{f_GetRowWithColumnsTs_args_attributes=Just s}
        else do
          skip iprot _t360
          read_GetRowWithColumnsTs_args_fields iprot record
      _ -> do
        skip iprot _t360
        readFieldEnd iprot
        read_GetRowWithColumnsTs_args_fields iprot record
read_GetRowWithColumnsTs_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowWithColumnsTs_args_fields iprot (GetRowWithColumnsTs_args{f_GetRowWithColumnsTs_args_tableName=Nothing,f_GetRowWithColumnsTs_args_row=Nothing,f_GetRowWithColumnsTs_args_columns=Nothing,f_GetRowWithColumnsTs_args_timestamp=Nothing,f_GetRowWithColumnsTs_args_attributes=Nothing})
  readStructEnd iprot
  return record
data GetRowWithColumnsTs_result = GetRowWithColumnsTs_result{f_GetRowWithColumnsTs_result_success :: Maybe (Vector.Vector TRowResult),f_GetRowWithColumnsTs_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetRowWithColumnsTs_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowWithColumnsTs_result_success record   `hashWithSalt` f_GetRowWithColumnsTs_result_io record  
write_GetRowWithColumnsTs_result oprot record = do
  writeStructBegin oprot "GetRowWithColumnsTs_result"
  case f_GetRowWithColumnsTs_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter374 -> write_TRowResult oprot _viter374) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowWithColumnsTs_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowWithColumnsTs_result_fields iprot record = do
  (_,_t376,_id377) <- readFieldBegin iprot
  if _t376 == T_STOP then return record else
    case _id377 of 
      0 -> if _t376 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TRowResult iprot)) in do {(_etype381,_size378) <- readListBegin iprot; f _size378})
        read_GetRowWithColumnsTs_result_fields iprot record{f_GetRowWithColumnsTs_result_success=Just s}
        else do
          skip iprot _t376
          read_GetRowWithColumnsTs_result_fields iprot record
      1 -> if _t376 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetRowWithColumnsTs_result_fields iprot record{f_GetRowWithColumnsTs_result_io=Just s}
        else do
          skip iprot _t376
          read_GetRowWithColumnsTs_result_fields iprot record
      _ -> do
        skip iprot _t376
        readFieldEnd iprot
        read_GetRowWithColumnsTs_result_fields iprot record
read_GetRowWithColumnsTs_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowWithColumnsTs_result_fields iprot (GetRowWithColumnsTs_result{f_GetRowWithColumnsTs_result_success=Nothing,f_GetRowWithColumnsTs_result_io=Nothing})
  readStructEnd iprot
  return record
data GetRows_args = GetRows_args{f_GetRows_args_tableName :: Maybe ByteString,f_GetRows_args_rows :: Maybe (Vector.Vector ByteString),f_GetRows_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable GetRows_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRows_args_tableName record   `hashWithSalt` f_GetRows_args_rows record   `hashWithSalt` f_GetRows_args_attributes record  
write_GetRows_args oprot record = do
  writeStructBegin oprot "GetRows_args"
  case f_GetRows_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRows_args_rows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rows",T_LIST,2)
    (let f = Vector.mapM_ (\_viter385 -> writeBinary oprot _viter385) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRows_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,3)
    (let {f [] = return (); f ((_kiter386,_viter387):t) = do {do {writeBinary oprot _kiter386;writeBinary oprot _viter387};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRows_args_fields iprot record = do
  (_,_t389,_id390) <- readFieldBegin iprot
  if _t389 == T_STOP then return record else
    case _id390 of 
      1 -> if _t389 == T_STRING then do
        s <- readBinary iprot
        read_GetRows_args_fields iprot record{f_GetRows_args_tableName=Just s}
        else do
          skip iprot _t389
          read_GetRows_args_fields iprot record
      2 -> if _t389 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype394,_size391) <- readListBegin iprot; f _size391})
        read_GetRows_args_fields iprot record{f_GetRows_args_rows=Just s}
        else do
          skip iprot _t389
          read_GetRows_args_fields iprot record
      3 -> if _t389 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype397,_vtype398,_size396) <- readMapBegin iprot; l <- f _size396; return $ Map.fromList l})
        read_GetRows_args_fields iprot record{f_GetRows_args_attributes=Just s}
        else do
          skip iprot _t389
          read_GetRows_args_fields iprot record
      _ -> do
        skip iprot _t389
        readFieldEnd iprot
        read_GetRows_args_fields iprot record
read_GetRows_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRows_args_fields iprot (GetRows_args{f_GetRows_args_tableName=Nothing,f_GetRows_args_rows=Nothing,f_GetRows_args_attributes=Nothing})
  readStructEnd iprot
  return record
data GetRows_result = GetRows_result{f_GetRows_result_success :: Maybe (Vector.Vector TRowResult),f_GetRows_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetRows_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRows_result_success record   `hashWithSalt` f_GetRows_result_io record  
write_GetRows_result oprot record = do
  writeStructBegin oprot "GetRows_result"
  case f_GetRows_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter403 -> write_TRowResult oprot _viter403) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRows_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRows_result_fields iprot record = do
  (_,_t405,_id406) <- readFieldBegin iprot
  if _t405 == T_STOP then return record else
    case _id406 of 
      0 -> if _t405 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TRowResult iprot)) in do {(_etype410,_size407) <- readListBegin iprot; f _size407})
        read_GetRows_result_fields iprot record{f_GetRows_result_success=Just s}
        else do
          skip iprot _t405
          read_GetRows_result_fields iprot record
      1 -> if _t405 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetRows_result_fields iprot record{f_GetRows_result_io=Just s}
        else do
          skip iprot _t405
          read_GetRows_result_fields iprot record
      _ -> do
        skip iprot _t405
        readFieldEnd iprot
        read_GetRows_result_fields iprot record
read_GetRows_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRows_result_fields iprot (GetRows_result{f_GetRows_result_success=Nothing,f_GetRows_result_io=Nothing})
  readStructEnd iprot
  return record
data GetRowsWithColumns_args = GetRowsWithColumns_args{f_GetRowsWithColumns_args_tableName :: Maybe ByteString,f_GetRowsWithColumns_args_rows :: Maybe (Vector.Vector ByteString),f_GetRowsWithColumns_args_columns :: Maybe (Vector.Vector ByteString),f_GetRowsWithColumns_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable GetRowsWithColumns_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowsWithColumns_args_tableName record   `hashWithSalt` f_GetRowsWithColumns_args_rows record   `hashWithSalt` f_GetRowsWithColumns_args_columns record   `hashWithSalt` f_GetRowsWithColumns_args_attributes record  
write_GetRowsWithColumns_args oprot record = do
  writeStructBegin oprot "GetRowsWithColumns_args"
  case f_GetRowsWithColumns_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRowsWithColumns_args_rows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rows",T_LIST,2)
    (let f = Vector.mapM_ (\_viter414 -> writeBinary oprot _viter414) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowsWithColumns_args_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,3)
    (let f = Vector.mapM_ (\_viter415 -> writeBinary oprot _viter415) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowsWithColumns_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter416,_viter417):t) = do {do {writeBinary oprot _kiter416;writeBinary oprot _viter417};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowsWithColumns_args_fields iprot record = do
  (_,_t419,_id420) <- readFieldBegin iprot
  if _t419 == T_STOP then return record else
    case _id420 of 
      1 -> if _t419 == T_STRING then do
        s <- readBinary iprot
        read_GetRowsWithColumns_args_fields iprot record{f_GetRowsWithColumns_args_tableName=Just s}
        else do
          skip iprot _t419
          read_GetRowsWithColumns_args_fields iprot record
      2 -> if _t419 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype424,_size421) <- readListBegin iprot; f _size421})
        read_GetRowsWithColumns_args_fields iprot record{f_GetRowsWithColumns_args_rows=Just s}
        else do
          skip iprot _t419
          read_GetRowsWithColumns_args_fields iprot record
      3 -> if _t419 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype429,_size426) <- readListBegin iprot; f _size426})
        read_GetRowsWithColumns_args_fields iprot record{f_GetRowsWithColumns_args_columns=Just s}
        else do
          skip iprot _t419
          read_GetRowsWithColumns_args_fields iprot record
      4 -> if _t419 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype432,_vtype433,_size431) <- readMapBegin iprot; l <- f _size431; return $ Map.fromList l})
        read_GetRowsWithColumns_args_fields iprot record{f_GetRowsWithColumns_args_attributes=Just s}
        else do
          skip iprot _t419
          read_GetRowsWithColumns_args_fields iprot record
      _ -> do
        skip iprot _t419
        readFieldEnd iprot
        read_GetRowsWithColumns_args_fields iprot record
read_GetRowsWithColumns_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowsWithColumns_args_fields iprot (GetRowsWithColumns_args{f_GetRowsWithColumns_args_tableName=Nothing,f_GetRowsWithColumns_args_rows=Nothing,f_GetRowsWithColumns_args_columns=Nothing,f_GetRowsWithColumns_args_attributes=Nothing})
  readStructEnd iprot
  return record
data GetRowsWithColumns_result = GetRowsWithColumns_result{f_GetRowsWithColumns_result_success :: Maybe (Vector.Vector TRowResult),f_GetRowsWithColumns_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetRowsWithColumns_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowsWithColumns_result_success record   `hashWithSalt` f_GetRowsWithColumns_result_io record  
write_GetRowsWithColumns_result oprot record = do
  writeStructBegin oprot "GetRowsWithColumns_result"
  case f_GetRowsWithColumns_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter438 -> write_TRowResult oprot _viter438) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowsWithColumns_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowsWithColumns_result_fields iprot record = do
  (_,_t440,_id441) <- readFieldBegin iprot
  if _t440 == T_STOP then return record else
    case _id441 of 
      0 -> if _t440 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TRowResult iprot)) in do {(_etype445,_size442) <- readListBegin iprot; f _size442})
        read_GetRowsWithColumns_result_fields iprot record{f_GetRowsWithColumns_result_success=Just s}
        else do
          skip iprot _t440
          read_GetRowsWithColumns_result_fields iprot record
      1 -> if _t440 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetRowsWithColumns_result_fields iprot record{f_GetRowsWithColumns_result_io=Just s}
        else do
          skip iprot _t440
          read_GetRowsWithColumns_result_fields iprot record
      _ -> do
        skip iprot _t440
        readFieldEnd iprot
        read_GetRowsWithColumns_result_fields iprot record
read_GetRowsWithColumns_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowsWithColumns_result_fields iprot (GetRowsWithColumns_result{f_GetRowsWithColumns_result_success=Nothing,f_GetRowsWithColumns_result_io=Nothing})
  readStructEnd iprot
  return record
data GetRowsTs_args = GetRowsTs_args{f_GetRowsTs_args_tableName :: Maybe ByteString,f_GetRowsTs_args_rows :: Maybe (Vector.Vector ByteString),f_GetRowsTs_args_timestamp :: Maybe Int64,f_GetRowsTs_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable GetRowsTs_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowsTs_args_tableName record   `hashWithSalt` f_GetRowsTs_args_rows record   `hashWithSalt` f_GetRowsTs_args_timestamp record   `hashWithSalt` f_GetRowsTs_args_attributes record  
write_GetRowsTs_args oprot record = do
  writeStructBegin oprot "GetRowsTs_args"
  case f_GetRowsTs_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRowsTs_args_rows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rows",T_LIST,2)
    (let f = Vector.mapM_ (\_viter449 -> writeBinary oprot _viter449) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowsTs_args_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_GetRowsTs_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter450,_viter451):t) = do {do {writeBinary oprot _kiter450;writeBinary oprot _viter451};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowsTs_args_fields iprot record = do
  (_,_t453,_id454) <- readFieldBegin iprot
  if _t453 == T_STOP then return record else
    case _id454 of 
      1 -> if _t453 == T_STRING then do
        s <- readBinary iprot
        read_GetRowsTs_args_fields iprot record{f_GetRowsTs_args_tableName=Just s}
        else do
          skip iprot _t453
          read_GetRowsTs_args_fields iprot record
      2 -> if _t453 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype458,_size455) <- readListBegin iprot; f _size455})
        read_GetRowsTs_args_fields iprot record{f_GetRowsTs_args_rows=Just s}
        else do
          skip iprot _t453
          read_GetRowsTs_args_fields iprot record
      3 -> if _t453 == T_I64 then do
        s <- readI64 iprot
        read_GetRowsTs_args_fields iprot record{f_GetRowsTs_args_timestamp=Just s}
        else do
          skip iprot _t453
          read_GetRowsTs_args_fields iprot record
      4 -> if _t453 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype461,_vtype462,_size460) <- readMapBegin iprot; l <- f _size460; return $ Map.fromList l})
        read_GetRowsTs_args_fields iprot record{f_GetRowsTs_args_attributes=Just s}
        else do
          skip iprot _t453
          read_GetRowsTs_args_fields iprot record
      _ -> do
        skip iprot _t453
        readFieldEnd iprot
        read_GetRowsTs_args_fields iprot record
read_GetRowsTs_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowsTs_args_fields iprot (GetRowsTs_args{f_GetRowsTs_args_tableName=Nothing,f_GetRowsTs_args_rows=Nothing,f_GetRowsTs_args_timestamp=Nothing,f_GetRowsTs_args_attributes=Nothing})
  readStructEnd iprot
  return record
data GetRowsTs_result = GetRowsTs_result{f_GetRowsTs_result_success :: Maybe (Vector.Vector TRowResult),f_GetRowsTs_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetRowsTs_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowsTs_result_success record   `hashWithSalt` f_GetRowsTs_result_io record  
write_GetRowsTs_result oprot record = do
  writeStructBegin oprot "GetRowsTs_result"
  case f_GetRowsTs_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter467 -> write_TRowResult oprot _viter467) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowsTs_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowsTs_result_fields iprot record = do
  (_,_t469,_id470) <- readFieldBegin iprot
  if _t469 == T_STOP then return record else
    case _id470 of 
      0 -> if _t469 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TRowResult iprot)) in do {(_etype474,_size471) <- readListBegin iprot; f _size471})
        read_GetRowsTs_result_fields iprot record{f_GetRowsTs_result_success=Just s}
        else do
          skip iprot _t469
          read_GetRowsTs_result_fields iprot record
      1 -> if _t469 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetRowsTs_result_fields iprot record{f_GetRowsTs_result_io=Just s}
        else do
          skip iprot _t469
          read_GetRowsTs_result_fields iprot record
      _ -> do
        skip iprot _t469
        readFieldEnd iprot
        read_GetRowsTs_result_fields iprot record
read_GetRowsTs_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowsTs_result_fields iprot (GetRowsTs_result{f_GetRowsTs_result_success=Nothing,f_GetRowsTs_result_io=Nothing})
  readStructEnd iprot
  return record
data GetRowsWithColumnsTs_args = GetRowsWithColumnsTs_args{f_GetRowsWithColumnsTs_args_tableName :: Maybe ByteString,f_GetRowsWithColumnsTs_args_rows :: Maybe (Vector.Vector ByteString),f_GetRowsWithColumnsTs_args_columns :: Maybe (Vector.Vector ByteString),f_GetRowsWithColumnsTs_args_timestamp :: Maybe Int64,f_GetRowsWithColumnsTs_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable GetRowsWithColumnsTs_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowsWithColumnsTs_args_tableName record   `hashWithSalt` f_GetRowsWithColumnsTs_args_rows record   `hashWithSalt` f_GetRowsWithColumnsTs_args_columns record   `hashWithSalt` f_GetRowsWithColumnsTs_args_timestamp record   `hashWithSalt` f_GetRowsWithColumnsTs_args_attributes record  
write_GetRowsWithColumnsTs_args oprot record = do
  writeStructBegin oprot "GetRowsWithColumnsTs_args"
  case f_GetRowsWithColumnsTs_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRowsWithColumnsTs_args_rows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rows",T_LIST,2)
    (let f = Vector.mapM_ (\_viter478 -> writeBinary oprot _viter478) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowsWithColumnsTs_args_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,3)
    (let f = Vector.mapM_ (\_viter479 -> writeBinary oprot _viter479) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowsWithColumnsTs_args_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,4)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_GetRowsWithColumnsTs_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,5)
    (let {f [] = return (); f ((_kiter480,_viter481):t) = do {do {writeBinary oprot _kiter480;writeBinary oprot _viter481};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowsWithColumnsTs_args_fields iprot record = do
  (_,_t483,_id484) <- readFieldBegin iprot
  if _t483 == T_STOP then return record else
    case _id484 of 
      1 -> if _t483 == T_STRING then do
        s <- readBinary iprot
        read_GetRowsWithColumnsTs_args_fields iprot record{f_GetRowsWithColumnsTs_args_tableName=Just s}
        else do
          skip iprot _t483
          read_GetRowsWithColumnsTs_args_fields iprot record
      2 -> if _t483 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype488,_size485) <- readListBegin iprot; f _size485})
        read_GetRowsWithColumnsTs_args_fields iprot record{f_GetRowsWithColumnsTs_args_rows=Just s}
        else do
          skip iprot _t483
          read_GetRowsWithColumnsTs_args_fields iprot record
      3 -> if _t483 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype493,_size490) <- readListBegin iprot; f _size490})
        read_GetRowsWithColumnsTs_args_fields iprot record{f_GetRowsWithColumnsTs_args_columns=Just s}
        else do
          skip iprot _t483
          read_GetRowsWithColumnsTs_args_fields iprot record
      4 -> if _t483 == T_I64 then do
        s <- readI64 iprot
        read_GetRowsWithColumnsTs_args_fields iprot record{f_GetRowsWithColumnsTs_args_timestamp=Just s}
        else do
          skip iprot _t483
          read_GetRowsWithColumnsTs_args_fields iprot record
      5 -> if _t483 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype496,_vtype497,_size495) <- readMapBegin iprot; l <- f _size495; return $ Map.fromList l})
        read_GetRowsWithColumnsTs_args_fields iprot record{f_GetRowsWithColumnsTs_args_attributes=Just s}
        else do
          skip iprot _t483
          read_GetRowsWithColumnsTs_args_fields iprot record
      _ -> do
        skip iprot _t483
        readFieldEnd iprot
        read_GetRowsWithColumnsTs_args_fields iprot record
read_GetRowsWithColumnsTs_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowsWithColumnsTs_args_fields iprot (GetRowsWithColumnsTs_args{f_GetRowsWithColumnsTs_args_tableName=Nothing,f_GetRowsWithColumnsTs_args_rows=Nothing,f_GetRowsWithColumnsTs_args_columns=Nothing,f_GetRowsWithColumnsTs_args_timestamp=Nothing,f_GetRowsWithColumnsTs_args_attributes=Nothing})
  readStructEnd iprot
  return record
data GetRowsWithColumnsTs_result = GetRowsWithColumnsTs_result{f_GetRowsWithColumnsTs_result_success :: Maybe (Vector.Vector TRowResult),f_GetRowsWithColumnsTs_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetRowsWithColumnsTs_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowsWithColumnsTs_result_success record   `hashWithSalt` f_GetRowsWithColumnsTs_result_io record  
write_GetRowsWithColumnsTs_result oprot record = do
  writeStructBegin oprot "GetRowsWithColumnsTs_result"
  case f_GetRowsWithColumnsTs_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter502 -> write_TRowResult oprot _viter502) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowsWithColumnsTs_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowsWithColumnsTs_result_fields iprot record = do
  (_,_t504,_id505) <- readFieldBegin iprot
  if _t504 == T_STOP then return record else
    case _id505 of 
      0 -> if _t504 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TRowResult iprot)) in do {(_etype509,_size506) <- readListBegin iprot; f _size506})
        read_GetRowsWithColumnsTs_result_fields iprot record{f_GetRowsWithColumnsTs_result_success=Just s}
        else do
          skip iprot _t504
          read_GetRowsWithColumnsTs_result_fields iprot record
      1 -> if _t504 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetRowsWithColumnsTs_result_fields iprot record{f_GetRowsWithColumnsTs_result_io=Just s}
        else do
          skip iprot _t504
          read_GetRowsWithColumnsTs_result_fields iprot record
      _ -> do
        skip iprot _t504
        readFieldEnd iprot
        read_GetRowsWithColumnsTs_result_fields iprot record
read_GetRowsWithColumnsTs_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowsWithColumnsTs_result_fields iprot (GetRowsWithColumnsTs_result{f_GetRowsWithColumnsTs_result_success=Nothing,f_GetRowsWithColumnsTs_result_io=Nothing})
  readStructEnd iprot
  return record
data MutateRow_args = MutateRow_args{f_MutateRow_args_tableName :: Maybe ByteString,f_MutateRow_args_row :: Maybe ByteString,f_MutateRow_args_mutations :: Maybe (Vector.Vector Mutation),f_MutateRow_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable MutateRow_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_MutateRow_args_tableName record   `hashWithSalt` f_MutateRow_args_row record   `hashWithSalt` f_MutateRow_args_mutations record   `hashWithSalt` f_MutateRow_args_attributes record  
write_MutateRow_args oprot record = do
  writeStructBegin oprot "MutateRow_args"
  case f_MutateRow_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_MutateRow_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_MutateRow_args_mutations record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("mutations",T_LIST,3)
    (let f = Vector.mapM_ (\_viter513 -> write_Mutation oprot _viter513) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_MutateRow_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter514,_viter515):t) = do {do {writeBinary oprot _kiter514;writeBinary oprot _viter515};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MutateRow_args_fields iprot record = do
  (_,_t517,_id518) <- readFieldBegin iprot
  if _t517 == T_STOP then return record else
    case _id518 of 
      1 -> if _t517 == T_STRING then do
        s <- readBinary iprot
        read_MutateRow_args_fields iprot record{f_MutateRow_args_tableName=Just s}
        else do
          skip iprot _t517
          read_MutateRow_args_fields iprot record
      2 -> if _t517 == T_STRING then do
        s <- readBinary iprot
        read_MutateRow_args_fields iprot record{f_MutateRow_args_row=Just s}
        else do
          skip iprot _t517
          read_MutateRow_args_fields iprot record
      3 -> if _t517 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Mutation iprot)) in do {(_etype522,_size519) <- readListBegin iprot; f _size519})
        read_MutateRow_args_fields iprot record{f_MutateRow_args_mutations=Just s}
        else do
          skip iprot _t517
          read_MutateRow_args_fields iprot record
      4 -> if _t517 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype525,_vtype526,_size524) <- readMapBegin iprot; l <- f _size524; return $ Map.fromList l})
        read_MutateRow_args_fields iprot record{f_MutateRow_args_attributes=Just s}
        else do
          skip iprot _t517
          read_MutateRow_args_fields iprot record
      _ -> do
        skip iprot _t517
        readFieldEnd iprot
        read_MutateRow_args_fields iprot record
read_MutateRow_args iprot = do
  _ <- readStructBegin iprot
  record <- read_MutateRow_args_fields iprot (MutateRow_args{f_MutateRow_args_tableName=Nothing,f_MutateRow_args_row=Nothing,f_MutateRow_args_mutations=Nothing,f_MutateRow_args_attributes=Nothing})
  readStructEnd iprot
  return record
data MutateRow_result = MutateRow_result{f_MutateRow_result_io :: Maybe IOError,f_MutateRow_result_ia :: Maybe IllegalArgument} deriving (Show,Eq,Typeable)
instance Hashable MutateRow_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_MutateRow_result_io record   `hashWithSalt` f_MutateRow_result_ia record  
write_MutateRow_result oprot record = do
  writeStructBegin oprot "MutateRow_result"
  case f_MutateRow_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  case f_MutateRow_result_ia record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ia",T_STRUCT,2)
    write_IllegalArgument oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MutateRow_result_fields iprot record = do
  (_,_t532,_id533) <- readFieldBegin iprot
  if _t532 == T_STOP then return record else
    case _id533 of 
      1 -> if _t532 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_MutateRow_result_fields iprot record{f_MutateRow_result_io=Just s}
        else do
          skip iprot _t532
          read_MutateRow_result_fields iprot record
      2 -> if _t532 == T_STRUCT then do
        s <- (read_IllegalArgument iprot)
        read_MutateRow_result_fields iprot record{f_MutateRow_result_ia=Just s}
        else do
          skip iprot _t532
          read_MutateRow_result_fields iprot record
      _ -> do
        skip iprot _t532
        readFieldEnd iprot
        read_MutateRow_result_fields iprot record
read_MutateRow_result iprot = do
  _ <- readStructBegin iprot
  record <- read_MutateRow_result_fields iprot (MutateRow_result{f_MutateRow_result_io=Nothing,f_MutateRow_result_ia=Nothing})
  readStructEnd iprot
  return record
data MutateRowTs_args = MutateRowTs_args{f_MutateRowTs_args_tableName :: Maybe ByteString,f_MutateRowTs_args_row :: Maybe ByteString,f_MutateRowTs_args_mutations :: Maybe (Vector.Vector Mutation),f_MutateRowTs_args_timestamp :: Maybe Int64,f_MutateRowTs_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable MutateRowTs_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_MutateRowTs_args_tableName record   `hashWithSalt` f_MutateRowTs_args_row record   `hashWithSalt` f_MutateRowTs_args_mutations record   `hashWithSalt` f_MutateRowTs_args_timestamp record   `hashWithSalt` f_MutateRowTs_args_attributes record  
write_MutateRowTs_args oprot record = do
  writeStructBegin oprot "MutateRowTs_args"
  case f_MutateRowTs_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_MutateRowTs_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_MutateRowTs_args_mutations record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("mutations",T_LIST,3)
    (let f = Vector.mapM_ (\_viter536 -> write_Mutation oprot _viter536) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_MutateRowTs_args_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,4)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_MutateRowTs_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,5)
    (let {f [] = return (); f ((_kiter537,_viter538):t) = do {do {writeBinary oprot _kiter537;writeBinary oprot _viter538};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MutateRowTs_args_fields iprot record = do
  (_,_t540,_id541) <- readFieldBegin iprot
  if _t540 == T_STOP then return record else
    case _id541 of 
      1 -> if _t540 == T_STRING then do
        s <- readBinary iprot
        read_MutateRowTs_args_fields iprot record{f_MutateRowTs_args_tableName=Just s}
        else do
          skip iprot _t540
          read_MutateRowTs_args_fields iprot record
      2 -> if _t540 == T_STRING then do
        s <- readBinary iprot
        read_MutateRowTs_args_fields iprot record{f_MutateRowTs_args_row=Just s}
        else do
          skip iprot _t540
          read_MutateRowTs_args_fields iprot record
      3 -> if _t540 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Mutation iprot)) in do {(_etype545,_size542) <- readListBegin iprot; f _size542})
        read_MutateRowTs_args_fields iprot record{f_MutateRowTs_args_mutations=Just s}
        else do
          skip iprot _t540
          read_MutateRowTs_args_fields iprot record
      4 -> if _t540 == T_I64 then do
        s <- readI64 iprot
        read_MutateRowTs_args_fields iprot record{f_MutateRowTs_args_timestamp=Just s}
        else do
          skip iprot _t540
          read_MutateRowTs_args_fields iprot record
      5 -> if _t540 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype548,_vtype549,_size547) <- readMapBegin iprot; l <- f _size547; return $ Map.fromList l})
        read_MutateRowTs_args_fields iprot record{f_MutateRowTs_args_attributes=Just s}
        else do
          skip iprot _t540
          read_MutateRowTs_args_fields iprot record
      _ -> do
        skip iprot _t540
        readFieldEnd iprot
        read_MutateRowTs_args_fields iprot record
read_MutateRowTs_args iprot = do
  _ <- readStructBegin iprot
  record <- read_MutateRowTs_args_fields iprot (MutateRowTs_args{f_MutateRowTs_args_tableName=Nothing,f_MutateRowTs_args_row=Nothing,f_MutateRowTs_args_mutations=Nothing,f_MutateRowTs_args_timestamp=Nothing,f_MutateRowTs_args_attributes=Nothing})
  readStructEnd iprot
  return record
data MutateRowTs_result = MutateRowTs_result{f_MutateRowTs_result_io :: Maybe IOError,f_MutateRowTs_result_ia :: Maybe IllegalArgument} deriving (Show,Eq,Typeable)
instance Hashable MutateRowTs_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_MutateRowTs_result_io record   `hashWithSalt` f_MutateRowTs_result_ia record  
write_MutateRowTs_result oprot record = do
  writeStructBegin oprot "MutateRowTs_result"
  case f_MutateRowTs_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  case f_MutateRowTs_result_ia record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ia",T_STRUCT,2)
    write_IllegalArgument oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MutateRowTs_result_fields iprot record = do
  (_,_t555,_id556) <- readFieldBegin iprot
  if _t555 == T_STOP then return record else
    case _id556 of 
      1 -> if _t555 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_MutateRowTs_result_fields iprot record{f_MutateRowTs_result_io=Just s}
        else do
          skip iprot _t555
          read_MutateRowTs_result_fields iprot record
      2 -> if _t555 == T_STRUCT then do
        s <- (read_IllegalArgument iprot)
        read_MutateRowTs_result_fields iprot record{f_MutateRowTs_result_ia=Just s}
        else do
          skip iprot _t555
          read_MutateRowTs_result_fields iprot record
      _ -> do
        skip iprot _t555
        readFieldEnd iprot
        read_MutateRowTs_result_fields iprot record
read_MutateRowTs_result iprot = do
  _ <- readStructBegin iprot
  record <- read_MutateRowTs_result_fields iprot (MutateRowTs_result{f_MutateRowTs_result_io=Nothing,f_MutateRowTs_result_ia=Nothing})
  readStructEnd iprot
  return record
data MutateRows_args = MutateRows_args{f_MutateRows_args_tableName :: Maybe ByteString,f_MutateRows_args_rowBatches :: Maybe (Vector.Vector BatchMutation),f_MutateRows_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable MutateRows_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_MutateRows_args_tableName record   `hashWithSalt` f_MutateRows_args_rowBatches record   `hashWithSalt` f_MutateRows_args_attributes record  
write_MutateRows_args oprot record = do
  writeStructBegin oprot "MutateRows_args"
  case f_MutateRows_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_MutateRows_args_rowBatches record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rowBatches",T_LIST,2)
    (let f = Vector.mapM_ (\_viter559 -> write_BatchMutation oprot _viter559) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_MutateRows_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,3)
    (let {f [] = return (); f ((_kiter560,_viter561):t) = do {do {writeBinary oprot _kiter560;writeBinary oprot _viter561};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MutateRows_args_fields iprot record = do
  (_,_t563,_id564) <- readFieldBegin iprot
  if _t563 == T_STOP then return record else
    case _id564 of 
      1 -> if _t563 == T_STRING then do
        s <- readBinary iprot
        read_MutateRows_args_fields iprot record{f_MutateRows_args_tableName=Just s}
        else do
          skip iprot _t563
          read_MutateRows_args_fields iprot record
      2 -> if _t563 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_BatchMutation iprot)) in do {(_etype568,_size565) <- readListBegin iprot; f _size565})
        read_MutateRows_args_fields iprot record{f_MutateRows_args_rowBatches=Just s}
        else do
          skip iprot _t563
          read_MutateRows_args_fields iprot record
      3 -> if _t563 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype571,_vtype572,_size570) <- readMapBegin iprot; l <- f _size570; return $ Map.fromList l})
        read_MutateRows_args_fields iprot record{f_MutateRows_args_attributes=Just s}
        else do
          skip iprot _t563
          read_MutateRows_args_fields iprot record
      _ -> do
        skip iprot _t563
        readFieldEnd iprot
        read_MutateRows_args_fields iprot record
read_MutateRows_args iprot = do
  _ <- readStructBegin iprot
  record <- read_MutateRows_args_fields iprot (MutateRows_args{f_MutateRows_args_tableName=Nothing,f_MutateRows_args_rowBatches=Nothing,f_MutateRows_args_attributes=Nothing})
  readStructEnd iprot
  return record
data MutateRows_result = MutateRows_result{f_MutateRows_result_io :: Maybe IOError,f_MutateRows_result_ia :: Maybe IllegalArgument} deriving (Show,Eq,Typeable)
instance Hashable MutateRows_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_MutateRows_result_io record   `hashWithSalt` f_MutateRows_result_ia record  
write_MutateRows_result oprot record = do
  writeStructBegin oprot "MutateRows_result"
  case f_MutateRows_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  case f_MutateRows_result_ia record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ia",T_STRUCT,2)
    write_IllegalArgument oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MutateRows_result_fields iprot record = do
  (_,_t578,_id579) <- readFieldBegin iprot
  if _t578 == T_STOP then return record else
    case _id579 of 
      1 -> if _t578 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_MutateRows_result_fields iprot record{f_MutateRows_result_io=Just s}
        else do
          skip iprot _t578
          read_MutateRows_result_fields iprot record
      2 -> if _t578 == T_STRUCT then do
        s <- (read_IllegalArgument iprot)
        read_MutateRows_result_fields iprot record{f_MutateRows_result_ia=Just s}
        else do
          skip iprot _t578
          read_MutateRows_result_fields iprot record
      _ -> do
        skip iprot _t578
        readFieldEnd iprot
        read_MutateRows_result_fields iprot record
read_MutateRows_result iprot = do
  _ <- readStructBegin iprot
  record <- read_MutateRows_result_fields iprot (MutateRows_result{f_MutateRows_result_io=Nothing,f_MutateRows_result_ia=Nothing})
  readStructEnd iprot
  return record
data MutateRowsTs_args = MutateRowsTs_args{f_MutateRowsTs_args_tableName :: Maybe ByteString,f_MutateRowsTs_args_rowBatches :: Maybe (Vector.Vector BatchMutation),f_MutateRowsTs_args_timestamp :: Maybe Int64,f_MutateRowsTs_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable MutateRowsTs_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_MutateRowsTs_args_tableName record   `hashWithSalt` f_MutateRowsTs_args_rowBatches record   `hashWithSalt` f_MutateRowsTs_args_timestamp record   `hashWithSalt` f_MutateRowsTs_args_attributes record  
write_MutateRowsTs_args oprot record = do
  writeStructBegin oprot "MutateRowsTs_args"
  case f_MutateRowsTs_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_MutateRowsTs_args_rowBatches record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rowBatches",T_LIST,2)
    (let f = Vector.mapM_ (\_viter582 -> write_BatchMutation oprot _viter582) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_MutateRowsTs_args_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_MutateRowsTs_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter583,_viter584):t) = do {do {writeBinary oprot _kiter583;writeBinary oprot _viter584};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MutateRowsTs_args_fields iprot record = do
  (_,_t586,_id587) <- readFieldBegin iprot
  if _t586 == T_STOP then return record else
    case _id587 of 
      1 -> if _t586 == T_STRING then do
        s <- readBinary iprot
        read_MutateRowsTs_args_fields iprot record{f_MutateRowsTs_args_tableName=Just s}
        else do
          skip iprot _t586
          read_MutateRowsTs_args_fields iprot record
      2 -> if _t586 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_BatchMutation iprot)) in do {(_etype591,_size588) <- readListBegin iprot; f _size588})
        read_MutateRowsTs_args_fields iprot record{f_MutateRowsTs_args_rowBatches=Just s}
        else do
          skip iprot _t586
          read_MutateRowsTs_args_fields iprot record
      3 -> if _t586 == T_I64 then do
        s <- readI64 iprot
        read_MutateRowsTs_args_fields iprot record{f_MutateRowsTs_args_timestamp=Just s}
        else do
          skip iprot _t586
          read_MutateRowsTs_args_fields iprot record
      4 -> if _t586 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype594,_vtype595,_size593) <- readMapBegin iprot; l <- f _size593; return $ Map.fromList l})
        read_MutateRowsTs_args_fields iprot record{f_MutateRowsTs_args_attributes=Just s}
        else do
          skip iprot _t586
          read_MutateRowsTs_args_fields iprot record
      _ -> do
        skip iprot _t586
        readFieldEnd iprot
        read_MutateRowsTs_args_fields iprot record
read_MutateRowsTs_args iprot = do
  _ <- readStructBegin iprot
  record <- read_MutateRowsTs_args_fields iprot (MutateRowsTs_args{f_MutateRowsTs_args_tableName=Nothing,f_MutateRowsTs_args_rowBatches=Nothing,f_MutateRowsTs_args_timestamp=Nothing,f_MutateRowsTs_args_attributes=Nothing})
  readStructEnd iprot
  return record
data MutateRowsTs_result = MutateRowsTs_result{f_MutateRowsTs_result_io :: Maybe IOError,f_MutateRowsTs_result_ia :: Maybe IllegalArgument} deriving (Show,Eq,Typeable)
instance Hashable MutateRowsTs_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_MutateRowsTs_result_io record   `hashWithSalt` f_MutateRowsTs_result_ia record  
write_MutateRowsTs_result oprot record = do
  writeStructBegin oprot "MutateRowsTs_result"
  case f_MutateRowsTs_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  case f_MutateRowsTs_result_ia record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ia",T_STRUCT,2)
    write_IllegalArgument oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MutateRowsTs_result_fields iprot record = do
  (_,_t601,_id602) <- readFieldBegin iprot
  if _t601 == T_STOP then return record else
    case _id602 of 
      1 -> if _t601 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_MutateRowsTs_result_fields iprot record{f_MutateRowsTs_result_io=Just s}
        else do
          skip iprot _t601
          read_MutateRowsTs_result_fields iprot record
      2 -> if _t601 == T_STRUCT then do
        s <- (read_IllegalArgument iprot)
        read_MutateRowsTs_result_fields iprot record{f_MutateRowsTs_result_ia=Just s}
        else do
          skip iprot _t601
          read_MutateRowsTs_result_fields iprot record
      _ -> do
        skip iprot _t601
        readFieldEnd iprot
        read_MutateRowsTs_result_fields iprot record
read_MutateRowsTs_result iprot = do
  _ <- readStructBegin iprot
  record <- read_MutateRowsTs_result_fields iprot (MutateRowsTs_result{f_MutateRowsTs_result_io=Nothing,f_MutateRowsTs_result_ia=Nothing})
  readStructEnd iprot
  return record
data AtomicIncrement_args = AtomicIncrement_args{f_AtomicIncrement_args_tableName :: Maybe ByteString,f_AtomicIncrement_args_row :: Maybe ByteString,f_AtomicIncrement_args_column :: Maybe ByteString,f_AtomicIncrement_args_value :: Maybe Int64} deriving (Show,Eq,Typeable)
instance Hashable AtomicIncrement_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_AtomicIncrement_args_tableName record   `hashWithSalt` f_AtomicIncrement_args_row record   `hashWithSalt` f_AtomicIncrement_args_column record   `hashWithSalt` f_AtomicIncrement_args_value record  
write_AtomicIncrement_args oprot record = do
  writeStructBegin oprot "AtomicIncrement_args"
  case f_AtomicIncrement_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_AtomicIncrement_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_AtomicIncrement_args_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_AtomicIncrement_args_value record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("value",T_I64,4)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AtomicIncrement_args_fields iprot record = do
  (_,_t606,_id607) <- readFieldBegin iprot
  if _t606 == T_STOP then return record else
    case _id607 of 
      1 -> if _t606 == T_STRING then do
        s <- readBinary iprot
        read_AtomicIncrement_args_fields iprot record{f_AtomicIncrement_args_tableName=Just s}
        else do
          skip iprot _t606
          read_AtomicIncrement_args_fields iprot record
      2 -> if _t606 == T_STRING then do
        s <- readBinary iprot
        read_AtomicIncrement_args_fields iprot record{f_AtomicIncrement_args_row=Just s}
        else do
          skip iprot _t606
          read_AtomicIncrement_args_fields iprot record
      3 -> if _t606 == T_STRING then do
        s <- readBinary iprot
        read_AtomicIncrement_args_fields iprot record{f_AtomicIncrement_args_column=Just s}
        else do
          skip iprot _t606
          read_AtomicIncrement_args_fields iprot record
      4 -> if _t606 == T_I64 then do
        s <- readI64 iprot
        read_AtomicIncrement_args_fields iprot record{f_AtomicIncrement_args_value=Just s}
        else do
          skip iprot _t606
          read_AtomicIncrement_args_fields iprot record
      _ -> do
        skip iprot _t606
        readFieldEnd iprot
        read_AtomicIncrement_args_fields iprot record
read_AtomicIncrement_args iprot = do
  _ <- readStructBegin iprot
  record <- read_AtomicIncrement_args_fields iprot (AtomicIncrement_args{f_AtomicIncrement_args_tableName=Nothing,f_AtomicIncrement_args_row=Nothing,f_AtomicIncrement_args_column=Nothing,f_AtomicIncrement_args_value=Nothing})
  readStructEnd iprot
  return record
data AtomicIncrement_result = AtomicIncrement_result{f_AtomicIncrement_result_success :: Maybe Int64,f_AtomicIncrement_result_io :: Maybe IOError,f_AtomicIncrement_result_ia :: Maybe IllegalArgument} deriving (Show,Eq,Typeable)
instance Hashable AtomicIncrement_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_AtomicIncrement_result_success record   `hashWithSalt` f_AtomicIncrement_result_io record   `hashWithSalt` f_AtomicIncrement_result_ia record  
write_AtomicIncrement_result oprot record = do
  writeStructBegin oprot "AtomicIncrement_result"
  case f_AtomicIncrement_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_I64,0)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_AtomicIncrement_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  case f_AtomicIncrement_result_ia record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ia",T_STRUCT,2)
    write_IllegalArgument oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AtomicIncrement_result_fields iprot record = do
  (_,_t611,_id612) <- readFieldBegin iprot
  if _t611 == T_STOP then return record else
    case _id612 of 
      0 -> if _t611 == T_I64 then do
        s <- readI64 iprot
        read_AtomicIncrement_result_fields iprot record{f_AtomicIncrement_result_success=Just s}
        else do
          skip iprot _t611
          read_AtomicIncrement_result_fields iprot record
      1 -> if _t611 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_AtomicIncrement_result_fields iprot record{f_AtomicIncrement_result_io=Just s}
        else do
          skip iprot _t611
          read_AtomicIncrement_result_fields iprot record
      2 -> if _t611 == T_STRUCT then do
        s <- (read_IllegalArgument iprot)
        read_AtomicIncrement_result_fields iprot record{f_AtomicIncrement_result_ia=Just s}
        else do
          skip iprot _t611
          read_AtomicIncrement_result_fields iprot record
      _ -> do
        skip iprot _t611
        readFieldEnd iprot
        read_AtomicIncrement_result_fields iprot record
read_AtomicIncrement_result iprot = do
  _ <- readStructBegin iprot
  record <- read_AtomicIncrement_result_fields iprot (AtomicIncrement_result{f_AtomicIncrement_result_success=Nothing,f_AtomicIncrement_result_io=Nothing,f_AtomicIncrement_result_ia=Nothing})
  readStructEnd iprot
  return record
data DeleteAll_args = DeleteAll_args{f_DeleteAll_args_tableName :: Maybe ByteString,f_DeleteAll_args_row :: Maybe ByteString,f_DeleteAll_args_column :: Maybe ByteString,f_DeleteAll_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable DeleteAll_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteAll_args_tableName record   `hashWithSalt` f_DeleteAll_args_row record   `hashWithSalt` f_DeleteAll_args_column record   `hashWithSalt` f_DeleteAll_args_attributes record  
write_DeleteAll_args oprot record = do
  writeStructBegin oprot "DeleteAll_args"
  case f_DeleteAll_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteAll_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteAll_args_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteAll_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter615,_viter616):t) = do {do {writeBinary oprot _kiter615;writeBinary oprot _viter616};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteAll_args_fields iprot record = do
  (_,_t618,_id619) <- readFieldBegin iprot
  if _t618 == T_STOP then return record else
    case _id619 of 
      1 -> if _t618 == T_STRING then do
        s <- readBinary iprot
        read_DeleteAll_args_fields iprot record{f_DeleteAll_args_tableName=Just s}
        else do
          skip iprot _t618
          read_DeleteAll_args_fields iprot record
      2 -> if _t618 == T_STRING then do
        s <- readBinary iprot
        read_DeleteAll_args_fields iprot record{f_DeleteAll_args_row=Just s}
        else do
          skip iprot _t618
          read_DeleteAll_args_fields iprot record
      3 -> if _t618 == T_STRING then do
        s <- readBinary iprot
        read_DeleteAll_args_fields iprot record{f_DeleteAll_args_column=Just s}
        else do
          skip iprot _t618
          read_DeleteAll_args_fields iprot record
      4 -> if _t618 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype621,_vtype622,_size620) <- readMapBegin iprot; l <- f _size620; return $ Map.fromList l})
        read_DeleteAll_args_fields iprot record{f_DeleteAll_args_attributes=Just s}
        else do
          skip iprot _t618
          read_DeleteAll_args_fields iprot record
      _ -> do
        skip iprot _t618
        readFieldEnd iprot
        read_DeleteAll_args_fields iprot record
read_DeleteAll_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteAll_args_fields iprot (DeleteAll_args{f_DeleteAll_args_tableName=Nothing,f_DeleteAll_args_row=Nothing,f_DeleteAll_args_column=Nothing,f_DeleteAll_args_attributes=Nothing})
  readStructEnd iprot
  return record
data DeleteAll_result = DeleteAll_result{f_DeleteAll_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable DeleteAll_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteAll_result_io record  
write_DeleteAll_result oprot record = do
  writeStructBegin oprot "DeleteAll_result"
  case f_DeleteAll_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteAll_result_fields iprot record = do
  (_,_t628,_id629) <- readFieldBegin iprot
  if _t628 == T_STOP then return record else
    case _id629 of 
      1 -> if _t628 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_DeleteAll_result_fields iprot record{f_DeleteAll_result_io=Just s}
        else do
          skip iprot _t628
          read_DeleteAll_result_fields iprot record
      _ -> do
        skip iprot _t628
        readFieldEnd iprot
        read_DeleteAll_result_fields iprot record
read_DeleteAll_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteAll_result_fields iprot (DeleteAll_result{f_DeleteAll_result_io=Nothing})
  readStructEnd iprot
  return record
data DeleteAllTs_args = DeleteAllTs_args{f_DeleteAllTs_args_tableName :: Maybe ByteString,f_DeleteAllTs_args_row :: Maybe ByteString,f_DeleteAllTs_args_column :: Maybe ByteString,f_DeleteAllTs_args_timestamp :: Maybe Int64,f_DeleteAllTs_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable DeleteAllTs_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteAllTs_args_tableName record   `hashWithSalt` f_DeleteAllTs_args_row record   `hashWithSalt` f_DeleteAllTs_args_column record   `hashWithSalt` f_DeleteAllTs_args_timestamp record   `hashWithSalt` f_DeleteAllTs_args_attributes record  
write_DeleteAllTs_args oprot record = do
  writeStructBegin oprot "DeleteAllTs_args"
  case f_DeleteAllTs_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteAllTs_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteAllTs_args_column record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("column",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteAllTs_args_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,4)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_DeleteAllTs_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,5)
    (let {f [] = return (); f ((_kiter632,_viter633):t) = do {do {writeBinary oprot _kiter632;writeBinary oprot _viter633};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteAllTs_args_fields iprot record = do
  (_,_t635,_id636) <- readFieldBegin iprot
  if _t635 == T_STOP then return record else
    case _id636 of 
      1 -> if _t635 == T_STRING then do
        s <- readBinary iprot
        read_DeleteAllTs_args_fields iprot record{f_DeleteAllTs_args_tableName=Just s}
        else do
          skip iprot _t635
          read_DeleteAllTs_args_fields iprot record
      2 -> if _t635 == T_STRING then do
        s <- readBinary iprot
        read_DeleteAllTs_args_fields iprot record{f_DeleteAllTs_args_row=Just s}
        else do
          skip iprot _t635
          read_DeleteAllTs_args_fields iprot record
      3 -> if _t635 == T_STRING then do
        s <- readBinary iprot
        read_DeleteAllTs_args_fields iprot record{f_DeleteAllTs_args_column=Just s}
        else do
          skip iprot _t635
          read_DeleteAllTs_args_fields iprot record
      4 -> if _t635 == T_I64 then do
        s <- readI64 iprot
        read_DeleteAllTs_args_fields iprot record{f_DeleteAllTs_args_timestamp=Just s}
        else do
          skip iprot _t635
          read_DeleteAllTs_args_fields iprot record
      5 -> if _t635 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype638,_vtype639,_size637) <- readMapBegin iprot; l <- f _size637; return $ Map.fromList l})
        read_DeleteAllTs_args_fields iprot record{f_DeleteAllTs_args_attributes=Just s}
        else do
          skip iprot _t635
          read_DeleteAllTs_args_fields iprot record
      _ -> do
        skip iprot _t635
        readFieldEnd iprot
        read_DeleteAllTs_args_fields iprot record
read_DeleteAllTs_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteAllTs_args_fields iprot (DeleteAllTs_args{f_DeleteAllTs_args_tableName=Nothing,f_DeleteAllTs_args_row=Nothing,f_DeleteAllTs_args_column=Nothing,f_DeleteAllTs_args_timestamp=Nothing,f_DeleteAllTs_args_attributes=Nothing})
  readStructEnd iprot
  return record
data DeleteAllTs_result = DeleteAllTs_result{f_DeleteAllTs_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable DeleteAllTs_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteAllTs_result_io record  
write_DeleteAllTs_result oprot record = do
  writeStructBegin oprot "DeleteAllTs_result"
  case f_DeleteAllTs_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteAllTs_result_fields iprot record = do
  (_,_t645,_id646) <- readFieldBegin iprot
  if _t645 == T_STOP then return record else
    case _id646 of 
      1 -> if _t645 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_DeleteAllTs_result_fields iprot record{f_DeleteAllTs_result_io=Just s}
        else do
          skip iprot _t645
          read_DeleteAllTs_result_fields iprot record
      _ -> do
        skip iprot _t645
        readFieldEnd iprot
        read_DeleteAllTs_result_fields iprot record
read_DeleteAllTs_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteAllTs_result_fields iprot (DeleteAllTs_result{f_DeleteAllTs_result_io=Nothing})
  readStructEnd iprot
  return record
data DeleteAllRow_args = DeleteAllRow_args{f_DeleteAllRow_args_tableName :: Maybe ByteString,f_DeleteAllRow_args_row :: Maybe ByteString,f_DeleteAllRow_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable DeleteAllRow_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteAllRow_args_tableName record   `hashWithSalt` f_DeleteAllRow_args_row record   `hashWithSalt` f_DeleteAllRow_args_attributes record  
write_DeleteAllRow_args oprot record = do
  writeStructBegin oprot "DeleteAllRow_args"
  case f_DeleteAllRow_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteAllRow_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteAllRow_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,3)
    (let {f [] = return (); f ((_kiter649,_viter650):t) = do {do {writeBinary oprot _kiter649;writeBinary oprot _viter650};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteAllRow_args_fields iprot record = do
  (_,_t652,_id653) <- readFieldBegin iprot
  if _t652 == T_STOP then return record else
    case _id653 of 
      1 -> if _t652 == T_STRING then do
        s <- readBinary iprot
        read_DeleteAllRow_args_fields iprot record{f_DeleteAllRow_args_tableName=Just s}
        else do
          skip iprot _t652
          read_DeleteAllRow_args_fields iprot record
      2 -> if _t652 == T_STRING then do
        s <- readBinary iprot
        read_DeleteAllRow_args_fields iprot record{f_DeleteAllRow_args_row=Just s}
        else do
          skip iprot _t652
          read_DeleteAllRow_args_fields iprot record
      3 -> if _t652 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype655,_vtype656,_size654) <- readMapBegin iprot; l <- f _size654; return $ Map.fromList l})
        read_DeleteAllRow_args_fields iprot record{f_DeleteAllRow_args_attributes=Just s}
        else do
          skip iprot _t652
          read_DeleteAllRow_args_fields iprot record
      _ -> do
        skip iprot _t652
        readFieldEnd iprot
        read_DeleteAllRow_args_fields iprot record
read_DeleteAllRow_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteAllRow_args_fields iprot (DeleteAllRow_args{f_DeleteAllRow_args_tableName=Nothing,f_DeleteAllRow_args_row=Nothing,f_DeleteAllRow_args_attributes=Nothing})
  readStructEnd iprot
  return record
data DeleteAllRow_result = DeleteAllRow_result{f_DeleteAllRow_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable DeleteAllRow_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteAllRow_result_io record  
write_DeleteAllRow_result oprot record = do
  writeStructBegin oprot "DeleteAllRow_result"
  case f_DeleteAllRow_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteAllRow_result_fields iprot record = do
  (_,_t662,_id663) <- readFieldBegin iprot
  if _t662 == T_STOP then return record else
    case _id663 of 
      1 -> if _t662 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_DeleteAllRow_result_fields iprot record{f_DeleteAllRow_result_io=Just s}
        else do
          skip iprot _t662
          read_DeleteAllRow_result_fields iprot record
      _ -> do
        skip iprot _t662
        readFieldEnd iprot
        read_DeleteAllRow_result_fields iprot record
read_DeleteAllRow_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteAllRow_result_fields iprot (DeleteAllRow_result{f_DeleteAllRow_result_io=Nothing})
  readStructEnd iprot
  return record
data Increment_args = Increment_args{f_Increment_args_increment :: Maybe TIncrement} deriving (Show,Eq,Typeable)
instance Hashable Increment_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Increment_args_increment record  
write_Increment_args oprot record = do
  writeStructBegin oprot "Increment_args"
  case f_Increment_args_increment record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("increment",T_STRUCT,1)
    write_TIncrement oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Increment_args_fields iprot record = do
  (_,_t667,_id668) <- readFieldBegin iprot
  if _t667 == T_STOP then return record else
    case _id668 of 
      1 -> if _t667 == T_STRUCT then do
        s <- (read_TIncrement iprot)
        read_Increment_args_fields iprot record{f_Increment_args_increment=Just s}
        else do
          skip iprot _t667
          read_Increment_args_fields iprot record
      _ -> do
        skip iprot _t667
        readFieldEnd iprot
        read_Increment_args_fields iprot record
read_Increment_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Increment_args_fields iprot (Increment_args{f_Increment_args_increment=Nothing})
  readStructEnd iprot
  return record
data Increment_result = Increment_result{f_Increment_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable Increment_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Increment_result_io record  
write_Increment_result oprot record = do
  writeStructBegin oprot "Increment_result"
  case f_Increment_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Increment_result_fields iprot record = do
  (_,_t672,_id673) <- readFieldBegin iprot
  if _t672 == T_STOP then return record else
    case _id673 of 
      1 -> if _t672 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_Increment_result_fields iprot record{f_Increment_result_io=Just s}
        else do
          skip iprot _t672
          read_Increment_result_fields iprot record
      _ -> do
        skip iprot _t672
        readFieldEnd iprot
        read_Increment_result_fields iprot record
read_Increment_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Increment_result_fields iprot (Increment_result{f_Increment_result_io=Nothing})
  readStructEnd iprot
  return record
data IncrementRows_args = IncrementRows_args{f_IncrementRows_args_increments :: Maybe (Vector.Vector TIncrement)} deriving (Show,Eq,Typeable)
instance Hashable IncrementRows_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_IncrementRows_args_increments record  
write_IncrementRows_args oprot record = do
  writeStructBegin oprot "IncrementRows_args"
  case f_IncrementRows_args_increments record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("increments",T_LIST,1)
    (let f = Vector.mapM_ (\_viter676 -> write_TIncrement oprot _viter676) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_IncrementRows_args_fields iprot record = do
  (_,_t678,_id679) <- readFieldBegin iprot
  if _t678 == T_STOP then return record else
    case _id679 of 
      1 -> if _t678 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TIncrement iprot)) in do {(_etype683,_size680) <- readListBegin iprot; f _size680})
        read_IncrementRows_args_fields iprot record{f_IncrementRows_args_increments=Just s}
        else do
          skip iprot _t678
          read_IncrementRows_args_fields iprot record
      _ -> do
        skip iprot _t678
        readFieldEnd iprot
        read_IncrementRows_args_fields iprot record
read_IncrementRows_args iprot = do
  _ <- readStructBegin iprot
  record <- read_IncrementRows_args_fields iprot (IncrementRows_args{f_IncrementRows_args_increments=Nothing})
  readStructEnd iprot
  return record
data IncrementRows_result = IncrementRows_result{f_IncrementRows_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable IncrementRows_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_IncrementRows_result_io record  
write_IncrementRows_result oprot record = do
  writeStructBegin oprot "IncrementRows_result"
  case f_IncrementRows_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_IncrementRows_result_fields iprot record = do
  (_,_t688,_id689) <- readFieldBegin iprot
  if _t688 == T_STOP then return record else
    case _id689 of 
      1 -> if _t688 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_IncrementRows_result_fields iprot record{f_IncrementRows_result_io=Just s}
        else do
          skip iprot _t688
          read_IncrementRows_result_fields iprot record
      _ -> do
        skip iprot _t688
        readFieldEnd iprot
        read_IncrementRows_result_fields iprot record
read_IncrementRows_result iprot = do
  _ <- readStructBegin iprot
  record <- read_IncrementRows_result_fields iprot (IncrementRows_result{f_IncrementRows_result_io=Nothing})
  readStructEnd iprot
  return record
data DeleteAllRowTs_args = DeleteAllRowTs_args{f_DeleteAllRowTs_args_tableName :: Maybe ByteString,f_DeleteAllRowTs_args_row :: Maybe ByteString,f_DeleteAllRowTs_args_timestamp :: Maybe Int64,f_DeleteAllRowTs_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable DeleteAllRowTs_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteAllRowTs_args_tableName record   `hashWithSalt` f_DeleteAllRowTs_args_row record   `hashWithSalt` f_DeleteAllRowTs_args_timestamp record   `hashWithSalt` f_DeleteAllRowTs_args_attributes record  
write_DeleteAllRowTs_args oprot record = do
  writeStructBegin oprot "DeleteAllRowTs_args"
  case f_DeleteAllRowTs_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteAllRowTs_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_DeleteAllRowTs_args_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_DeleteAllRowTs_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter692,_viter693):t) = do {do {writeBinary oprot _kiter692;writeBinary oprot _viter693};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteAllRowTs_args_fields iprot record = do
  (_,_t695,_id696) <- readFieldBegin iprot
  if _t695 == T_STOP then return record else
    case _id696 of 
      1 -> if _t695 == T_STRING then do
        s <- readBinary iprot
        read_DeleteAllRowTs_args_fields iprot record{f_DeleteAllRowTs_args_tableName=Just s}
        else do
          skip iprot _t695
          read_DeleteAllRowTs_args_fields iprot record
      2 -> if _t695 == T_STRING then do
        s <- readBinary iprot
        read_DeleteAllRowTs_args_fields iprot record{f_DeleteAllRowTs_args_row=Just s}
        else do
          skip iprot _t695
          read_DeleteAllRowTs_args_fields iprot record
      3 -> if _t695 == T_I64 then do
        s <- readI64 iprot
        read_DeleteAllRowTs_args_fields iprot record{f_DeleteAllRowTs_args_timestamp=Just s}
        else do
          skip iprot _t695
          read_DeleteAllRowTs_args_fields iprot record
      4 -> if _t695 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype698,_vtype699,_size697) <- readMapBegin iprot; l <- f _size697; return $ Map.fromList l})
        read_DeleteAllRowTs_args_fields iprot record{f_DeleteAllRowTs_args_attributes=Just s}
        else do
          skip iprot _t695
          read_DeleteAllRowTs_args_fields iprot record
      _ -> do
        skip iprot _t695
        readFieldEnd iprot
        read_DeleteAllRowTs_args_fields iprot record
read_DeleteAllRowTs_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteAllRowTs_args_fields iprot (DeleteAllRowTs_args{f_DeleteAllRowTs_args_tableName=Nothing,f_DeleteAllRowTs_args_row=Nothing,f_DeleteAllRowTs_args_timestamp=Nothing,f_DeleteAllRowTs_args_attributes=Nothing})
  readStructEnd iprot
  return record
data DeleteAllRowTs_result = DeleteAllRowTs_result{f_DeleteAllRowTs_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable DeleteAllRowTs_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DeleteAllRowTs_result_io record  
write_DeleteAllRowTs_result oprot record = do
  writeStructBegin oprot "DeleteAllRowTs_result"
  case f_DeleteAllRowTs_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DeleteAllRowTs_result_fields iprot record = do
  (_,_t705,_id706) <- readFieldBegin iprot
  if _t705 == T_STOP then return record else
    case _id706 of 
      1 -> if _t705 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_DeleteAllRowTs_result_fields iprot record{f_DeleteAllRowTs_result_io=Just s}
        else do
          skip iprot _t705
          read_DeleteAllRowTs_result_fields iprot record
      _ -> do
        skip iprot _t705
        readFieldEnd iprot
        read_DeleteAllRowTs_result_fields iprot record
read_DeleteAllRowTs_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DeleteAllRowTs_result_fields iprot (DeleteAllRowTs_result{f_DeleteAllRowTs_result_io=Nothing})
  readStructEnd iprot
  return record
data ScannerOpenWithScan_args = ScannerOpenWithScan_args{f_ScannerOpenWithScan_args_tableName :: Maybe ByteString,f_ScannerOpenWithScan_args_scan :: Maybe TScan,f_ScannerOpenWithScan_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpenWithScan_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpenWithScan_args_tableName record   `hashWithSalt` f_ScannerOpenWithScan_args_scan record   `hashWithSalt` f_ScannerOpenWithScan_args_attributes record  
write_ScannerOpenWithScan_args oprot record = do
  writeStructBegin oprot "ScannerOpenWithScan_args"
  case f_ScannerOpenWithScan_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithScan_args_scan record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("scan",T_STRUCT,2)
    write_TScan oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithScan_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,3)
    (let {f [] = return (); f ((_kiter709,_viter710):t) = do {do {writeBinary oprot _kiter709;writeBinary oprot _viter710};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpenWithScan_args_fields iprot record = do
  (_,_t712,_id713) <- readFieldBegin iprot
  if _t712 == T_STOP then return record else
    case _id713 of 
      1 -> if _t712 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpenWithScan_args_fields iprot record{f_ScannerOpenWithScan_args_tableName=Just s}
        else do
          skip iprot _t712
          read_ScannerOpenWithScan_args_fields iprot record
      2 -> if _t712 == T_STRUCT then do
        s <- (read_TScan iprot)
        read_ScannerOpenWithScan_args_fields iprot record{f_ScannerOpenWithScan_args_scan=Just s}
        else do
          skip iprot _t712
          read_ScannerOpenWithScan_args_fields iprot record
      3 -> if _t712 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype715,_vtype716,_size714) <- readMapBegin iprot; l <- f _size714; return $ Map.fromList l})
        read_ScannerOpenWithScan_args_fields iprot record{f_ScannerOpenWithScan_args_attributes=Just s}
        else do
          skip iprot _t712
          read_ScannerOpenWithScan_args_fields iprot record
      _ -> do
        skip iprot _t712
        readFieldEnd iprot
        read_ScannerOpenWithScan_args_fields iprot record
read_ScannerOpenWithScan_args iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpenWithScan_args_fields iprot (ScannerOpenWithScan_args{f_ScannerOpenWithScan_args_tableName=Nothing,f_ScannerOpenWithScan_args_scan=Nothing,f_ScannerOpenWithScan_args_attributes=Nothing})
  readStructEnd iprot
  return record
data ScannerOpenWithScan_result = ScannerOpenWithScan_result{f_ScannerOpenWithScan_result_success :: Maybe Int32,f_ScannerOpenWithScan_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpenWithScan_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpenWithScan_result_success record   `hashWithSalt` f_ScannerOpenWithScan_result_io record  
write_ScannerOpenWithScan_result oprot record = do
  writeStructBegin oprot "ScannerOpenWithScan_result"
  case f_ScannerOpenWithScan_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_I32,0)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithScan_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpenWithScan_result_fields iprot record = do
  (_,_t722,_id723) <- readFieldBegin iprot
  if _t722 == T_STOP then return record else
    case _id723 of 
      0 -> if _t722 == T_I32 then do
        s <- readI32 iprot
        read_ScannerOpenWithScan_result_fields iprot record{f_ScannerOpenWithScan_result_success=Just s}
        else do
          skip iprot _t722
          read_ScannerOpenWithScan_result_fields iprot record
      1 -> if _t722 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_ScannerOpenWithScan_result_fields iprot record{f_ScannerOpenWithScan_result_io=Just s}
        else do
          skip iprot _t722
          read_ScannerOpenWithScan_result_fields iprot record
      _ -> do
        skip iprot _t722
        readFieldEnd iprot
        read_ScannerOpenWithScan_result_fields iprot record
read_ScannerOpenWithScan_result iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpenWithScan_result_fields iprot (ScannerOpenWithScan_result{f_ScannerOpenWithScan_result_success=Nothing,f_ScannerOpenWithScan_result_io=Nothing})
  readStructEnd iprot
  return record
data ScannerOpen_args = ScannerOpen_args{f_ScannerOpen_args_tableName :: Maybe ByteString,f_ScannerOpen_args_startRow :: Maybe ByteString,f_ScannerOpen_args_columns :: Maybe (Vector.Vector ByteString),f_ScannerOpen_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpen_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpen_args_tableName record   `hashWithSalt` f_ScannerOpen_args_startRow record   `hashWithSalt` f_ScannerOpen_args_columns record   `hashWithSalt` f_ScannerOpen_args_attributes record  
write_ScannerOpen_args oprot record = do
  writeStructBegin oprot "ScannerOpen_args"
  case f_ScannerOpen_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpen_args_startRow record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("startRow",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpen_args_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,3)
    (let f = Vector.mapM_ (\_viter726 -> writeBinary oprot _viter726) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_ScannerOpen_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter727,_viter728):t) = do {do {writeBinary oprot _kiter727;writeBinary oprot _viter728};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpen_args_fields iprot record = do
  (_,_t730,_id731) <- readFieldBegin iprot
  if _t730 == T_STOP then return record else
    case _id731 of 
      1 -> if _t730 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpen_args_fields iprot record{f_ScannerOpen_args_tableName=Just s}
        else do
          skip iprot _t730
          read_ScannerOpen_args_fields iprot record
      2 -> if _t730 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpen_args_fields iprot record{f_ScannerOpen_args_startRow=Just s}
        else do
          skip iprot _t730
          read_ScannerOpen_args_fields iprot record
      3 -> if _t730 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype735,_size732) <- readListBegin iprot; f _size732})
        read_ScannerOpen_args_fields iprot record{f_ScannerOpen_args_columns=Just s}
        else do
          skip iprot _t730
          read_ScannerOpen_args_fields iprot record
      4 -> if _t730 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype738,_vtype739,_size737) <- readMapBegin iprot; l <- f _size737; return $ Map.fromList l})
        read_ScannerOpen_args_fields iprot record{f_ScannerOpen_args_attributes=Just s}
        else do
          skip iprot _t730
          read_ScannerOpen_args_fields iprot record
      _ -> do
        skip iprot _t730
        readFieldEnd iprot
        read_ScannerOpen_args_fields iprot record
read_ScannerOpen_args iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpen_args_fields iprot (ScannerOpen_args{f_ScannerOpen_args_tableName=Nothing,f_ScannerOpen_args_startRow=Nothing,f_ScannerOpen_args_columns=Nothing,f_ScannerOpen_args_attributes=Nothing})
  readStructEnd iprot
  return record
data ScannerOpen_result = ScannerOpen_result{f_ScannerOpen_result_success :: Maybe Int32,f_ScannerOpen_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpen_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpen_result_success record   `hashWithSalt` f_ScannerOpen_result_io record  
write_ScannerOpen_result oprot record = do
  writeStructBegin oprot "ScannerOpen_result"
  case f_ScannerOpen_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_I32,0)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpen_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpen_result_fields iprot record = do
  (_,_t745,_id746) <- readFieldBegin iprot
  if _t745 == T_STOP then return record else
    case _id746 of 
      0 -> if _t745 == T_I32 then do
        s <- readI32 iprot
        read_ScannerOpen_result_fields iprot record{f_ScannerOpen_result_success=Just s}
        else do
          skip iprot _t745
          read_ScannerOpen_result_fields iprot record
      1 -> if _t745 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_ScannerOpen_result_fields iprot record{f_ScannerOpen_result_io=Just s}
        else do
          skip iprot _t745
          read_ScannerOpen_result_fields iprot record
      _ -> do
        skip iprot _t745
        readFieldEnd iprot
        read_ScannerOpen_result_fields iprot record
read_ScannerOpen_result iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpen_result_fields iprot (ScannerOpen_result{f_ScannerOpen_result_success=Nothing,f_ScannerOpen_result_io=Nothing})
  readStructEnd iprot
  return record
data ScannerOpenWithStop_args = ScannerOpenWithStop_args{f_ScannerOpenWithStop_args_tableName :: Maybe ByteString,f_ScannerOpenWithStop_args_startRow :: Maybe ByteString,f_ScannerOpenWithStop_args_stopRow :: Maybe ByteString,f_ScannerOpenWithStop_args_columns :: Maybe (Vector.Vector ByteString),f_ScannerOpenWithStop_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpenWithStop_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpenWithStop_args_tableName record   `hashWithSalt` f_ScannerOpenWithStop_args_startRow record   `hashWithSalt` f_ScannerOpenWithStop_args_stopRow record   `hashWithSalt` f_ScannerOpenWithStop_args_columns record   `hashWithSalt` f_ScannerOpenWithStop_args_attributes record  
write_ScannerOpenWithStop_args oprot record = do
  writeStructBegin oprot "ScannerOpenWithStop_args"
  case f_ScannerOpenWithStop_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithStop_args_startRow record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("startRow",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithStop_args_stopRow record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("stopRow",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithStop_args_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,4)
    (let f = Vector.mapM_ (\_viter749 -> writeBinary oprot _viter749) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_ScannerOpenWithStop_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,5)
    (let {f [] = return (); f ((_kiter750,_viter751):t) = do {do {writeBinary oprot _kiter750;writeBinary oprot _viter751};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpenWithStop_args_fields iprot record = do
  (_,_t753,_id754) <- readFieldBegin iprot
  if _t753 == T_STOP then return record else
    case _id754 of 
      1 -> if _t753 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpenWithStop_args_fields iprot record{f_ScannerOpenWithStop_args_tableName=Just s}
        else do
          skip iprot _t753
          read_ScannerOpenWithStop_args_fields iprot record
      2 -> if _t753 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpenWithStop_args_fields iprot record{f_ScannerOpenWithStop_args_startRow=Just s}
        else do
          skip iprot _t753
          read_ScannerOpenWithStop_args_fields iprot record
      3 -> if _t753 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpenWithStop_args_fields iprot record{f_ScannerOpenWithStop_args_stopRow=Just s}
        else do
          skip iprot _t753
          read_ScannerOpenWithStop_args_fields iprot record
      4 -> if _t753 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype758,_size755) <- readListBegin iprot; f _size755})
        read_ScannerOpenWithStop_args_fields iprot record{f_ScannerOpenWithStop_args_columns=Just s}
        else do
          skip iprot _t753
          read_ScannerOpenWithStop_args_fields iprot record
      5 -> if _t753 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype761,_vtype762,_size760) <- readMapBegin iprot; l <- f _size760; return $ Map.fromList l})
        read_ScannerOpenWithStop_args_fields iprot record{f_ScannerOpenWithStop_args_attributes=Just s}
        else do
          skip iprot _t753
          read_ScannerOpenWithStop_args_fields iprot record
      _ -> do
        skip iprot _t753
        readFieldEnd iprot
        read_ScannerOpenWithStop_args_fields iprot record
read_ScannerOpenWithStop_args iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpenWithStop_args_fields iprot (ScannerOpenWithStop_args{f_ScannerOpenWithStop_args_tableName=Nothing,f_ScannerOpenWithStop_args_startRow=Nothing,f_ScannerOpenWithStop_args_stopRow=Nothing,f_ScannerOpenWithStop_args_columns=Nothing,f_ScannerOpenWithStop_args_attributes=Nothing})
  readStructEnd iprot
  return record
data ScannerOpenWithStop_result = ScannerOpenWithStop_result{f_ScannerOpenWithStop_result_success :: Maybe Int32,f_ScannerOpenWithStop_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpenWithStop_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpenWithStop_result_success record   `hashWithSalt` f_ScannerOpenWithStop_result_io record  
write_ScannerOpenWithStop_result oprot record = do
  writeStructBegin oprot "ScannerOpenWithStop_result"
  case f_ScannerOpenWithStop_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_I32,0)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithStop_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpenWithStop_result_fields iprot record = do
  (_,_t768,_id769) <- readFieldBegin iprot
  if _t768 == T_STOP then return record else
    case _id769 of 
      0 -> if _t768 == T_I32 then do
        s <- readI32 iprot
        read_ScannerOpenWithStop_result_fields iprot record{f_ScannerOpenWithStop_result_success=Just s}
        else do
          skip iprot _t768
          read_ScannerOpenWithStop_result_fields iprot record
      1 -> if _t768 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_ScannerOpenWithStop_result_fields iprot record{f_ScannerOpenWithStop_result_io=Just s}
        else do
          skip iprot _t768
          read_ScannerOpenWithStop_result_fields iprot record
      _ -> do
        skip iprot _t768
        readFieldEnd iprot
        read_ScannerOpenWithStop_result_fields iprot record
read_ScannerOpenWithStop_result iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpenWithStop_result_fields iprot (ScannerOpenWithStop_result{f_ScannerOpenWithStop_result_success=Nothing,f_ScannerOpenWithStop_result_io=Nothing})
  readStructEnd iprot
  return record
data ScannerOpenWithPrefix_args = ScannerOpenWithPrefix_args{f_ScannerOpenWithPrefix_args_tableName :: Maybe ByteString,f_ScannerOpenWithPrefix_args_startAndPrefix :: Maybe ByteString,f_ScannerOpenWithPrefix_args_columns :: Maybe (Vector.Vector ByteString),f_ScannerOpenWithPrefix_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpenWithPrefix_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpenWithPrefix_args_tableName record   `hashWithSalt` f_ScannerOpenWithPrefix_args_startAndPrefix record   `hashWithSalt` f_ScannerOpenWithPrefix_args_columns record   `hashWithSalt` f_ScannerOpenWithPrefix_args_attributes record  
write_ScannerOpenWithPrefix_args oprot record = do
  writeStructBegin oprot "ScannerOpenWithPrefix_args"
  case f_ScannerOpenWithPrefix_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithPrefix_args_startAndPrefix record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("startAndPrefix",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithPrefix_args_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,3)
    (let f = Vector.mapM_ (\_viter772 -> writeBinary oprot _viter772) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_ScannerOpenWithPrefix_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,4)
    (let {f [] = return (); f ((_kiter773,_viter774):t) = do {do {writeBinary oprot _kiter773;writeBinary oprot _viter774};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpenWithPrefix_args_fields iprot record = do
  (_,_t776,_id777) <- readFieldBegin iprot
  if _t776 == T_STOP then return record else
    case _id777 of 
      1 -> if _t776 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpenWithPrefix_args_fields iprot record{f_ScannerOpenWithPrefix_args_tableName=Just s}
        else do
          skip iprot _t776
          read_ScannerOpenWithPrefix_args_fields iprot record
      2 -> if _t776 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpenWithPrefix_args_fields iprot record{f_ScannerOpenWithPrefix_args_startAndPrefix=Just s}
        else do
          skip iprot _t776
          read_ScannerOpenWithPrefix_args_fields iprot record
      3 -> if _t776 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype781,_size778) <- readListBegin iprot; f _size778})
        read_ScannerOpenWithPrefix_args_fields iprot record{f_ScannerOpenWithPrefix_args_columns=Just s}
        else do
          skip iprot _t776
          read_ScannerOpenWithPrefix_args_fields iprot record
      4 -> if _t776 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype784,_vtype785,_size783) <- readMapBegin iprot; l <- f _size783; return $ Map.fromList l})
        read_ScannerOpenWithPrefix_args_fields iprot record{f_ScannerOpenWithPrefix_args_attributes=Just s}
        else do
          skip iprot _t776
          read_ScannerOpenWithPrefix_args_fields iprot record
      _ -> do
        skip iprot _t776
        readFieldEnd iprot
        read_ScannerOpenWithPrefix_args_fields iprot record
read_ScannerOpenWithPrefix_args iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpenWithPrefix_args_fields iprot (ScannerOpenWithPrefix_args{f_ScannerOpenWithPrefix_args_tableName=Nothing,f_ScannerOpenWithPrefix_args_startAndPrefix=Nothing,f_ScannerOpenWithPrefix_args_columns=Nothing,f_ScannerOpenWithPrefix_args_attributes=Nothing})
  readStructEnd iprot
  return record
data ScannerOpenWithPrefix_result = ScannerOpenWithPrefix_result{f_ScannerOpenWithPrefix_result_success :: Maybe Int32,f_ScannerOpenWithPrefix_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpenWithPrefix_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpenWithPrefix_result_success record   `hashWithSalt` f_ScannerOpenWithPrefix_result_io record  
write_ScannerOpenWithPrefix_result oprot record = do
  writeStructBegin oprot "ScannerOpenWithPrefix_result"
  case f_ScannerOpenWithPrefix_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_I32,0)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithPrefix_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpenWithPrefix_result_fields iprot record = do
  (_,_t791,_id792) <- readFieldBegin iprot
  if _t791 == T_STOP then return record else
    case _id792 of 
      0 -> if _t791 == T_I32 then do
        s <- readI32 iprot
        read_ScannerOpenWithPrefix_result_fields iprot record{f_ScannerOpenWithPrefix_result_success=Just s}
        else do
          skip iprot _t791
          read_ScannerOpenWithPrefix_result_fields iprot record
      1 -> if _t791 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_ScannerOpenWithPrefix_result_fields iprot record{f_ScannerOpenWithPrefix_result_io=Just s}
        else do
          skip iprot _t791
          read_ScannerOpenWithPrefix_result_fields iprot record
      _ -> do
        skip iprot _t791
        readFieldEnd iprot
        read_ScannerOpenWithPrefix_result_fields iprot record
read_ScannerOpenWithPrefix_result iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpenWithPrefix_result_fields iprot (ScannerOpenWithPrefix_result{f_ScannerOpenWithPrefix_result_success=Nothing,f_ScannerOpenWithPrefix_result_io=Nothing})
  readStructEnd iprot
  return record
data ScannerOpenTs_args = ScannerOpenTs_args{f_ScannerOpenTs_args_tableName :: Maybe ByteString,f_ScannerOpenTs_args_startRow :: Maybe ByteString,f_ScannerOpenTs_args_columns :: Maybe (Vector.Vector ByteString),f_ScannerOpenTs_args_timestamp :: Maybe Int64,f_ScannerOpenTs_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpenTs_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpenTs_args_tableName record   `hashWithSalt` f_ScannerOpenTs_args_startRow record   `hashWithSalt` f_ScannerOpenTs_args_columns record   `hashWithSalt` f_ScannerOpenTs_args_timestamp record   `hashWithSalt` f_ScannerOpenTs_args_attributes record  
write_ScannerOpenTs_args oprot record = do
  writeStructBegin oprot "ScannerOpenTs_args"
  case f_ScannerOpenTs_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenTs_args_startRow record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("startRow",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenTs_args_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,3)
    (let f = Vector.mapM_ (\_viter795 -> writeBinary oprot _viter795) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_ScannerOpenTs_args_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,4)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenTs_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,5)
    (let {f [] = return (); f ((_kiter796,_viter797):t) = do {do {writeBinary oprot _kiter796;writeBinary oprot _viter797};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpenTs_args_fields iprot record = do
  (_,_t799,_id800) <- readFieldBegin iprot
  if _t799 == T_STOP then return record else
    case _id800 of 
      1 -> if _t799 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpenTs_args_fields iprot record{f_ScannerOpenTs_args_tableName=Just s}
        else do
          skip iprot _t799
          read_ScannerOpenTs_args_fields iprot record
      2 -> if _t799 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpenTs_args_fields iprot record{f_ScannerOpenTs_args_startRow=Just s}
        else do
          skip iprot _t799
          read_ScannerOpenTs_args_fields iprot record
      3 -> if _t799 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype804,_size801) <- readListBegin iprot; f _size801})
        read_ScannerOpenTs_args_fields iprot record{f_ScannerOpenTs_args_columns=Just s}
        else do
          skip iprot _t799
          read_ScannerOpenTs_args_fields iprot record
      4 -> if _t799 == T_I64 then do
        s <- readI64 iprot
        read_ScannerOpenTs_args_fields iprot record{f_ScannerOpenTs_args_timestamp=Just s}
        else do
          skip iprot _t799
          read_ScannerOpenTs_args_fields iprot record
      5 -> if _t799 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype807,_vtype808,_size806) <- readMapBegin iprot; l <- f _size806; return $ Map.fromList l})
        read_ScannerOpenTs_args_fields iprot record{f_ScannerOpenTs_args_attributes=Just s}
        else do
          skip iprot _t799
          read_ScannerOpenTs_args_fields iprot record
      _ -> do
        skip iprot _t799
        readFieldEnd iprot
        read_ScannerOpenTs_args_fields iprot record
read_ScannerOpenTs_args iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpenTs_args_fields iprot (ScannerOpenTs_args{f_ScannerOpenTs_args_tableName=Nothing,f_ScannerOpenTs_args_startRow=Nothing,f_ScannerOpenTs_args_columns=Nothing,f_ScannerOpenTs_args_timestamp=Nothing,f_ScannerOpenTs_args_attributes=Nothing})
  readStructEnd iprot
  return record
data ScannerOpenTs_result = ScannerOpenTs_result{f_ScannerOpenTs_result_success :: Maybe Int32,f_ScannerOpenTs_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpenTs_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpenTs_result_success record   `hashWithSalt` f_ScannerOpenTs_result_io record  
write_ScannerOpenTs_result oprot record = do
  writeStructBegin oprot "ScannerOpenTs_result"
  case f_ScannerOpenTs_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_I32,0)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenTs_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpenTs_result_fields iprot record = do
  (_,_t814,_id815) <- readFieldBegin iprot
  if _t814 == T_STOP then return record else
    case _id815 of 
      0 -> if _t814 == T_I32 then do
        s <- readI32 iprot
        read_ScannerOpenTs_result_fields iprot record{f_ScannerOpenTs_result_success=Just s}
        else do
          skip iprot _t814
          read_ScannerOpenTs_result_fields iprot record
      1 -> if _t814 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_ScannerOpenTs_result_fields iprot record{f_ScannerOpenTs_result_io=Just s}
        else do
          skip iprot _t814
          read_ScannerOpenTs_result_fields iprot record
      _ -> do
        skip iprot _t814
        readFieldEnd iprot
        read_ScannerOpenTs_result_fields iprot record
read_ScannerOpenTs_result iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpenTs_result_fields iprot (ScannerOpenTs_result{f_ScannerOpenTs_result_success=Nothing,f_ScannerOpenTs_result_io=Nothing})
  readStructEnd iprot
  return record
data ScannerOpenWithStopTs_args = ScannerOpenWithStopTs_args{f_ScannerOpenWithStopTs_args_tableName :: Maybe ByteString,f_ScannerOpenWithStopTs_args_startRow :: Maybe ByteString,f_ScannerOpenWithStopTs_args_stopRow :: Maybe ByteString,f_ScannerOpenWithStopTs_args_columns :: Maybe (Vector.Vector ByteString),f_ScannerOpenWithStopTs_args_timestamp :: Maybe Int64,f_ScannerOpenWithStopTs_args_attributes :: Maybe (Map.HashMap ByteString ByteString)} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpenWithStopTs_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpenWithStopTs_args_tableName record   `hashWithSalt` f_ScannerOpenWithStopTs_args_startRow record   `hashWithSalt` f_ScannerOpenWithStopTs_args_stopRow record   `hashWithSalt` f_ScannerOpenWithStopTs_args_columns record   `hashWithSalt` f_ScannerOpenWithStopTs_args_timestamp record   `hashWithSalt` f_ScannerOpenWithStopTs_args_attributes record  
write_ScannerOpenWithStopTs_args oprot record = do
  writeStructBegin oprot "ScannerOpenWithStopTs_args"
  case f_ScannerOpenWithStopTs_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithStopTs_args_startRow record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("startRow",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithStopTs_args_stopRow record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("stopRow",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithStopTs_args_columns record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("columns",T_LIST,4)
    (let f = Vector.mapM_ (\_viter818 -> writeBinary oprot _viter818) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_ScannerOpenWithStopTs_args_timestamp record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("timestamp",T_I64,5)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithStopTs_args_attributes record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attributes",T_MAP,6)
    (let {f [] = return (); f ((_kiter819,_viter820):t) = do {do {writeBinary oprot _kiter819;writeBinary oprot _viter820};f t}} in do {writeMapBegin oprot (T_STRING,T_STRING,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpenWithStopTs_args_fields iprot record = do
  (_,_t822,_id823) <- readFieldBegin iprot
  if _t822 == T_STOP then return record else
    case _id823 of 
      1 -> if _t822 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpenWithStopTs_args_fields iprot record{f_ScannerOpenWithStopTs_args_tableName=Just s}
        else do
          skip iprot _t822
          read_ScannerOpenWithStopTs_args_fields iprot record
      2 -> if _t822 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpenWithStopTs_args_fields iprot record{f_ScannerOpenWithStopTs_args_startRow=Just s}
        else do
          skip iprot _t822
          read_ScannerOpenWithStopTs_args_fields iprot record
      3 -> if _t822 == T_STRING then do
        s <- readBinary iprot
        read_ScannerOpenWithStopTs_args_fields iprot record{f_ScannerOpenWithStopTs_args_stopRow=Just s}
        else do
          skip iprot _t822
          read_ScannerOpenWithStopTs_args_fields iprot record
      4 -> if _t822 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readBinary iprot) in do {(_etype827,_size824) <- readListBegin iprot; f _size824})
        read_ScannerOpenWithStopTs_args_fields iprot record{f_ScannerOpenWithStopTs_args_columns=Just s}
        else do
          skip iprot _t822
          read_ScannerOpenWithStopTs_args_fields iprot record
      5 -> if _t822 == T_I64 then do
        s <- readI64 iprot
        read_ScannerOpenWithStopTs_args_fields iprot record{f_ScannerOpenWithStopTs_args_timestamp=Just s}
        else do
          skip iprot _t822
          read_ScannerOpenWithStopTs_args_fields iprot record
      6 -> if _t822 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- readBinary iprot; v <- readBinary iprot;r <- f (n-1); return $ (k,v):r}} in do {(_ktype830,_vtype831,_size829) <- readMapBegin iprot; l <- f _size829; return $ Map.fromList l})
        read_ScannerOpenWithStopTs_args_fields iprot record{f_ScannerOpenWithStopTs_args_attributes=Just s}
        else do
          skip iprot _t822
          read_ScannerOpenWithStopTs_args_fields iprot record
      _ -> do
        skip iprot _t822
        readFieldEnd iprot
        read_ScannerOpenWithStopTs_args_fields iprot record
read_ScannerOpenWithStopTs_args iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpenWithStopTs_args_fields iprot (ScannerOpenWithStopTs_args{f_ScannerOpenWithStopTs_args_tableName=Nothing,f_ScannerOpenWithStopTs_args_startRow=Nothing,f_ScannerOpenWithStopTs_args_stopRow=Nothing,f_ScannerOpenWithStopTs_args_columns=Nothing,f_ScannerOpenWithStopTs_args_timestamp=Nothing,f_ScannerOpenWithStopTs_args_attributes=Nothing})
  readStructEnd iprot
  return record
data ScannerOpenWithStopTs_result = ScannerOpenWithStopTs_result{f_ScannerOpenWithStopTs_result_success :: Maybe Int32,f_ScannerOpenWithStopTs_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable ScannerOpenWithStopTs_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerOpenWithStopTs_result_success record   `hashWithSalt` f_ScannerOpenWithStopTs_result_io record  
write_ScannerOpenWithStopTs_result oprot record = do
  writeStructBegin oprot "ScannerOpenWithStopTs_result"
  case f_ScannerOpenWithStopTs_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_I32,0)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_ScannerOpenWithStopTs_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerOpenWithStopTs_result_fields iprot record = do
  (_,_t837,_id838) <- readFieldBegin iprot
  if _t837 == T_STOP then return record else
    case _id838 of 
      0 -> if _t837 == T_I32 then do
        s <- readI32 iprot
        read_ScannerOpenWithStopTs_result_fields iprot record{f_ScannerOpenWithStopTs_result_success=Just s}
        else do
          skip iprot _t837
          read_ScannerOpenWithStopTs_result_fields iprot record
      1 -> if _t837 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_ScannerOpenWithStopTs_result_fields iprot record{f_ScannerOpenWithStopTs_result_io=Just s}
        else do
          skip iprot _t837
          read_ScannerOpenWithStopTs_result_fields iprot record
      _ -> do
        skip iprot _t837
        readFieldEnd iprot
        read_ScannerOpenWithStopTs_result_fields iprot record
read_ScannerOpenWithStopTs_result iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerOpenWithStopTs_result_fields iprot (ScannerOpenWithStopTs_result{f_ScannerOpenWithStopTs_result_success=Nothing,f_ScannerOpenWithStopTs_result_io=Nothing})
  readStructEnd iprot
  return record
data ScannerGet_args = ScannerGet_args{f_ScannerGet_args_id :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable ScannerGet_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerGet_args_id record  
write_ScannerGet_args oprot record = do
  writeStructBegin oprot "ScannerGet_args"
  case f_ScannerGet_args_id record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("id",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerGet_args_fields iprot record = do
  (_,_t842,_id843) <- readFieldBegin iprot
  if _t842 == T_STOP then return record else
    case _id843 of 
      1 -> if _t842 == T_I32 then do
        s <- readI32 iprot
        read_ScannerGet_args_fields iprot record{f_ScannerGet_args_id=Just s}
        else do
          skip iprot _t842
          read_ScannerGet_args_fields iprot record
      _ -> do
        skip iprot _t842
        readFieldEnd iprot
        read_ScannerGet_args_fields iprot record
read_ScannerGet_args iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerGet_args_fields iprot (ScannerGet_args{f_ScannerGet_args_id=Nothing})
  readStructEnd iprot
  return record
data ScannerGet_result = ScannerGet_result{f_ScannerGet_result_success :: Maybe (Vector.Vector TRowResult),f_ScannerGet_result_io :: Maybe IOError,f_ScannerGet_result_ia :: Maybe IllegalArgument} deriving (Show,Eq,Typeable)
instance Hashable ScannerGet_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerGet_result_success record   `hashWithSalt` f_ScannerGet_result_io record   `hashWithSalt` f_ScannerGet_result_ia record  
write_ScannerGet_result oprot record = do
  writeStructBegin oprot "ScannerGet_result"
  case f_ScannerGet_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter846 -> write_TRowResult oprot _viter846) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_ScannerGet_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  case f_ScannerGet_result_ia record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ia",T_STRUCT,2)
    write_IllegalArgument oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerGet_result_fields iprot record = do
  (_,_t848,_id849) <- readFieldBegin iprot
  if _t848 == T_STOP then return record else
    case _id849 of 
      0 -> if _t848 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TRowResult iprot)) in do {(_etype853,_size850) <- readListBegin iprot; f _size850})
        read_ScannerGet_result_fields iprot record{f_ScannerGet_result_success=Just s}
        else do
          skip iprot _t848
          read_ScannerGet_result_fields iprot record
      1 -> if _t848 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_ScannerGet_result_fields iprot record{f_ScannerGet_result_io=Just s}
        else do
          skip iprot _t848
          read_ScannerGet_result_fields iprot record
      2 -> if _t848 == T_STRUCT then do
        s <- (read_IllegalArgument iprot)
        read_ScannerGet_result_fields iprot record{f_ScannerGet_result_ia=Just s}
        else do
          skip iprot _t848
          read_ScannerGet_result_fields iprot record
      _ -> do
        skip iprot _t848
        readFieldEnd iprot
        read_ScannerGet_result_fields iprot record
read_ScannerGet_result iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerGet_result_fields iprot (ScannerGet_result{f_ScannerGet_result_success=Nothing,f_ScannerGet_result_io=Nothing,f_ScannerGet_result_ia=Nothing})
  readStructEnd iprot
  return record
data ScannerGetList_args = ScannerGetList_args{f_ScannerGetList_args_id :: Maybe Int32,f_ScannerGetList_args_nbRows :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable ScannerGetList_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerGetList_args_id record   `hashWithSalt` f_ScannerGetList_args_nbRows record  
write_ScannerGetList_args oprot record = do
  writeStructBegin oprot "ScannerGetList_args"
  case f_ScannerGetList_args_id record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("id",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_ScannerGetList_args_nbRows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("nbRows",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerGetList_args_fields iprot record = do
  (_,_t858,_id859) <- readFieldBegin iprot
  if _t858 == T_STOP then return record else
    case _id859 of 
      1 -> if _t858 == T_I32 then do
        s <- readI32 iprot
        read_ScannerGetList_args_fields iprot record{f_ScannerGetList_args_id=Just s}
        else do
          skip iprot _t858
          read_ScannerGetList_args_fields iprot record
      2 -> if _t858 == T_I32 then do
        s <- readI32 iprot
        read_ScannerGetList_args_fields iprot record{f_ScannerGetList_args_nbRows=Just s}
        else do
          skip iprot _t858
          read_ScannerGetList_args_fields iprot record
      _ -> do
        skip iprot _t858
        readFieldEnd iprot
        read_ScannerGetList_args_fields iprot record
read_ScannerGetList_args iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerGetList_args_fields iprot (ScannerGetList_args{f_ScannerGetList_args_id=Nothing,f_ScannerGetList_args_nbRows=Nothing})
  readStructEnd iprot
  return record
data ScannerGetList_result = ScannerGetList_result{f_ScannerGetList_result_success :: Maybe (Vector.Vector TRowResult),f_ScannerGetList_result_io :: Maybe IOError,f_ScannerGetList_result_ia :: Maybe IllegalArgument} deriving (Show,Eq,Typeable)
instance Hashable ScannerGetList_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerGetList_result_success record   `hashWithSalt` f_ScannerGetList_result_io record   `hashWithSalt` f_ScannerGetList_result_ia record  
write_ScannerGetList_result oprot record = do
  writeStructBegin oprot "ScannerGetList_result"
  case f_ScannerGetList_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter862 -> write_TRowResult oprot _viter862) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_ScannerGetList_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  case f_ScannerGetList_result_ia record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ia",T_STRUCT,2)
    write_IllegalArgument oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerGetList_result_fields iprot record = do
  (_,_t864,_id865) <- readFieldBegin iprot
  if _t864 == T_STOP then return record else
    case _id865 of 
      0 -> if _t864 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TRowResult iprot)) in do {(_etype869,_size866) <- readListBegin iprot; f _size866})
        read_ScannerGetList_result_fields iprot record{f_ScannerGetList_result_success=Just s}
        else do
          skip iprot _t864
          read_ScannerGetList_result_fields iprot record
      1 -> if _t864 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_ScannerGetList_result_fields iprot record{f_ScannerGetList_result_io=Just s}
        else do
          skip iprot _t864
          read_ScannerGetList_result_fields iprot record
      2 -> if _t864 == T_STRUCT then do
        s <- (read_IllegalArgument iprot)
        read_ScannerGetList_result_fields iprot record{f_ScannerGetList_result_ia=Just s}
        else do
          skip iprot _t864
          read_ScannerGetList_result_fields iprot record
      _ -> do
        skip iprot _t864
        readFieldEnd iprot
        read_ScannerGetList_result_fields iprot record
read_ScannerGetList_result iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerGetList_result_fields iprot (ScannerGetList_result{f_ScannerGetList_result_success=Nothing,f_ScannerGetList_result_io=Nothing,f_ScannerGetList_result_ia=Nothing})
  readStructEnd iprot
  return record
data ScannerClose_args = ScannerClose_args{f_ScannerClose_args_id :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable ScannerClose_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerClose_args_id record  
write_ScannerClose_args oprot record = do
  writeStructBegin oprot "ScannerClose_args"
  case f_ScannerClose_args_id record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("id",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerClose_args_fields iprot record = do
  (_,_t874,_id875) <- readFieldBegin iprot
  if _t874 == T_STOP then return record else
    case _id875 of 
      1 -> if _t874 == T_I32 then do
        s <- readI32 iprot
        read_ScannerClose_args_fields iprot record{f_ScannerClose_args_id=Just s}
        else do
          skip iprot _t874
          read_ScannerClose_args_fields iprot record
      _ -> do
        skip iprot _t874
        readFieldEnd iprot
        read_ScannerClose_args_fields iprot record
read_ScannerClose_args iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerClose_args_fields iprot (ScannerClose_args{f_ScannerClose_args_id=Nothing})
  readStructEnd iprot
  return record
data ScannerClose_result = ScannerClose_result{f_ScannerClose_result_io :: Maybe IOError,f_ScannerClose_result_ia :: Maybe IllegalArgument} deriving (Show,Eq,Typeable)
instance Hashable ScannerClose_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_ScannerClose_result_io record   `hashWithSalt` f_ScannerClose_result_ia record  
write_ScannerClose_result oprot record = do
  writeStructBegin oprot "ScannerClose_result"
  case f_ScannerClose_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  case f_ScannerClose_result_ia record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ia",T_STRUCT,2)
    write_IllegalArgument oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ScannerClose_result_fields iprot record = do
  (_,_t879,_id880) <- readFieldBegin iprot
  if _t879 == T_STOP then return record else
    case _id880 of 
      1 -> if _t879 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_ScannerClose_result_fields iprot record{f_ScannerClose_result_io=Just s}
        else do
          skip iprot _t879
          read_ScannerClose_result_fields iprot record
      2 -> if _t879 == T_STRUCT then do
        s <- (read_IllegalArgument iprot)
        read_ScannerClose_result_fields iprot record{f_ScannerClose_result_ia=Just s}
        else do
          skip iprot _t879
          read_ScannerClose_result_fields iprot record
      _ -> do
        skip iprot _t879
        readFieldEnd iprot
        read_ScannerClose_result_fields iprot record
read_ScannerClose_result iprot = do
  _ <- readStructBegin iprot
  record <- read_ScannerClose_result_fields iprot (ScannerClose_result{f_ScannerClose_result_io=Nothing,f_ScannerClose_result_ia=Nothing})
  readStructEnd iprot
  return record
data GetRowOrBefore_args = GetRowOrBefore_args{f_GetRowOrBefore_args_tableName :: Maybe ByteString,f_GetRowOrBefore_args_row :: Maybe ByteString,f_GetRowOrBefore_args_family :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable GetRowOrBefore_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowOrBefore_args_tableName record   `hashWithSalt` f_GetRowOrBefore_args_row record   `hashWithSalt` f_GetRowOrBefore_args_family record  
write_GetRowOrBefore_args oprot record = do
  writeStructBegin oprot "GetRowOrBefore_args"
  case f_GetRowOrBefore_args_tableName record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("tableName",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRowOrBefore_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,2)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_GetRowOrBefore_args_family record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("family",T_STRING,3)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowOrBefore_args_fields iprot record = do
  (_,_t884,_id885) <- readFieldBegin iprot
  if _t884 == T_STOP then return record else
    case _id885 of 
      1 -> if _t884 == T_STRING then do
        s <- readBinary iprot
        read_GetRowOrBefore_args_fields iprot record{f_GetRowOrBefore_args_tableName=Just s}
        else do
          skip iprot _t884
          read_GetRowOrBefore_args_fields iprot record
      2 -> if _t884 == T_STRING then do
        s <- readBinary iprot
        read_GetRowOrBefore_args_fields iprot record{f_GetRowOrBefore_args_row=Just s}
        else do
          skip iprot _t884
          read_GetRowOrBefore_args_fields iprot record
      3 -> if _t884 == T_STRING then do
        s <- readBinary iprot
        read_GetRowOrBefore_args_fields iprot record{f_GetRowOrBefore_args_family=Just s}
        else do
          skip iprot _t884
          read_GetRowOrBefore_args_fields iprot record
      _ -> do
        skip iprot _t884
        readFieldEnd iprot
        read_GetRowOrBefore_args_fields iprot record
read_GetRowOrBefore_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowOrBefore_args_fields iprot (GetRowOrBefore_args{f_GetRowOrBefore_args_tableName=Nothing,f_GetRowOrBefore_args_row=Nothing,f_GetRowOrBefore_args_family=Nothing})
  readStructEnd iprot
  return record
data GetRowOrBefore_result = GetRowOrBefore_result{f_GetRowOrBefore_result_success :: Maybe (Vector.Vector TCell),f_GetRowOrBefore_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetRowOrBefore_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRowOrBefore_result_success record   `hashWithSalt` f_GetRowOrBefore_result_io record  
write_GetRowOrBefore_result oprot record = do
  writeStructBegin oprot "GetRowOrBefore_result"
  case f_GetRowOrBefore_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter888 -> write_TCell oprot _viter888) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_GetRowOrBefore_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRowOrBefore_result_fields iprot record = do
  (_,_t890,_id891) <- readFieldBegin iprot
  if _t890 == T_STOP then return record else
    case _id891 of 
      0 -> if _t890 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_TCell iprot)) in do {(_etype895,_size892) <- readListBegin iprot; f _size892})
        read_GetRowOrBefore_result_fields iprot record{f_GetRowOrBefore_result_success=Just s}
        else do
          skip iprot _t890
          read_GetRowOrBefore_result_fields iprot record
      1 -> if _t890 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetRowOrBefore_result_fields iprot record{f_GetRowOrBefore_result_io=Just s}
        else do
          skip iprot _t890
          read_GetRowOrBefore_result_fields iprot record
      _ -> do
        skip iprot _t890
        readFieldEnd iprot
        read_GetRowOrBefore_result_fields iprot record
read_GetRowOrBefore_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRowOrBefore_result_fields iprot (GetRowOrBefore_result{f_GetRowOrBefore_result_success=Nothing,f_GetRowOrBefore_result_io=Nothing})
  readStructEnd iprot
  return record
data GetRegionInfo_args = GetRegionInfo_args{f_GetRegionInfo_args_row :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable GetRegionInfo_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRegionInfo_args_row record  
write_GetRegionInfo_args oprot record = do
  writeStructBegin oprot "GetRegionInfo_args"
  case f_GetRegionInfo_args_row record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("row",T_STRING,1)
    writeBinary oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRegionInfo_args_fields iprot record = do
  (_,_t900,_id901) <- readFieldBegin iprot
  if _t900 == T_STOP then return record else
    case _id901 of 
      1 -> if _t900 == T_STRING then do
        s <- readBinary iprot
        read_GetRegionInfo_args_fields iprot record{f_GetRegionInfo_args_row=Just s}
        else do
          skip iprot _t900
          read_GetRegionInfo_args_fields iprot record
      _ -> do
        skip iprot _t900
        readFieldEnd iprot
        read_GetRegionInfo_args_fields iprot record
read_GetRegionInfo_args iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRegionInfo_args_fields iprot (GetRegionInfo_args{f_GetRegionInfo_args_row=Nothing})
  readStructEnd iprot
  return record
data GetRegionInfo_result = GetRegionInfo_result{f_GetRegionInfo_result_success :: Maybe TRegionInfo,f_GetRegionInfo_result_io :: Maybe IOError} deriving (Show,Eq,Typeable)
instance Hashable GetRegionInfo_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_GetRegionInfo_result_success record   `hashWithSalt` f_GetRegionInfo_result_io record  
write_GetRegionInfo_result oprot record = do
  writeStructBegin oprot "GetRegionInfo_result"
  case f_GetRegionInfo_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    write_TRegionInfo oprot _v
    writeFieldEnd oprot}
  case f_GetRegionInfo_result_io record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("io",T_STRUCT,1)
    write_IOError oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GetRegionInfo_result_fields iprot record = do
  (_,_t905,_id906) <- readFieldBegin iprot
  if _t905 == T_STOP then return record else
    case _id906 of 
      0 -> if _t905 == T_STRUCT then do
        s <- (read_TRegionInfo iprot)
        read_GetRegionInfo_result_fields iprot record{f_GetRegionInfo_result_success=Just s}
        else do
          skip iprot _t905
          read_GetRegionInfo_result_fields iprot record
      1 -> if _t905 == T_STRUCT then do
        s <- (read_IOError iprot)
        read_GetRegionInfo_result_fields iprot record{f_GetRegionInfo_result_io=Just s}
        else do
          skip iprot _t905
          read_GetRegionInfo_result_fields iprot record
      _ -> do
        skip iprot _t905
        readFieldEnd iprot
        read_GetRegionInfo_result_fields iprot record
read_GetRegionInfo_result iprot = do
  _ <- readStructBegin iprot
  record <- read_GetRegionInfo_result_fields iprot (GetRegionInfo_result{f_GetRegionInfo_result_success=Nothing,f_GetRegionInfo_result_io=Nothing})
  readStructEnd iprot
  return record
process_enableTable (seqid, iprot, oprot, handler) = do
  args <- read_EnableTable_args iprot
  readMessageEnd iprot
  rs <- return (EnableTable_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.enableTable handler (f_EnableTable_args_tableName args)
      return rs)
    (\e  -> 
      return rs{f_EnableTable_result_io =Just e}))
  writeMessageBegin oprot ("enableTable", M_REPLY, seqid);
  write_EnableTable_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_disableTable (seqid, iprot, oprot, handler) = do
  args <- read_DisableTable_args iprot
  readMessageEnd iprot
  rs <- return (DisableTable_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.disableTable handler (f_DisableTable_args_tableName args)
      return rs)
    (\e  -> 
      return rs{f_DisableTable_result_io =Just e}))
  writeMessageBegin oprot ("disableTable", M_REPLY, seqid);
  write_DisableTable_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_isTableEnabled (seqid, iprot, oprot, handler) = do
  args <- read_IsTableEnabled_args iprot
  readMessageEnd iprot
  rs <- return (IsTableEnabled_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.isTableEnabled handler (f_IsTableEnabled_args_tableName args)
      return rs{f_IsTableEnabled_result_success= Just res})
    (\e  -> 
      return rs{f_IsTableEnabled_result_io =Just e}))
  writeMessageBegin oprot ("isTableEnabled", M_REPLY, seqid);
  write_IsTableEnabled_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_compact (seqid, iprot, oprot, handler) = do
  args <- read_Compact_args iprot
  readMessageEnd iprot
  rs <- return (Compact_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.compact handler (f_Compact_args_tableNameOrRegionName args)
      return rs)
    (\e  -> 
      return rs{f_Compact_result_io =Just e}))
  writeMessageBegin oprot ("compact", M_REPLY, seqid);
  write_Compact_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_majorCompact (seqid, iprot, oprot, handler) = do
  args <- read_MajorCompact_args iprot
  readMessageEnd iprot
  rs <- return (MajorCompact_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.majorCompact handler (f_MajorCompact_args_tableNameOrRegionName args)
      return rs)
    (\e  -> 
      return rs{f_MajorCompact_result_io =Just e}))
  writeMessageBegin oprot ("majorCompact", M_REPLY, seqid);
  write_MajorCompact_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getTableNames (seqid, iprot, oprot, handler) = do
  args <- read_GetTableNames_args iprot
  readMessageEnd iprot
  rs <- return (GetTableNames_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getTableNames handler
      return rs{f_GetTableNames_result_success= Just res})
    (\e  -> 
      return rs{f_GetTableNames_result_io =Just e}))
  writeMessageBegin oprot ("getTableNames", M_REPLY, seqid);
  write_GetTableNames_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getColumnDescriptors (seqid, iprot, oprot, handler) = do
  args <- read_GetColumnDescriptors_args iprot
  readMessageEnd iprot
  rs <- return (GetColumnDescriptors_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getColumnDescriptors handler (f_GetColumnDescriptors_args_tableName args)
      return rs{f_GetColumnDescriptors_result_success= Just res})
    (\e  -> 
      return rs{f_GetColumnDescriptors_result_io =Just e}))
  writeMessageBegin oprot ("getColumnDescriptors", M_REPLY, seqid);
  write_GetColumnDescriptors_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getTableRegions (seqid, iprot, oprot, handler) = do
  args <- read_GetTableRegions_args iprot
  readMessageEnd iprot
  rs <- return (GetTableRegions_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getTableRegions handler (f_GetTableRegions_args_tableName args)
      return rs{f_GetTableRegions_result_success= Just res})
    (\e  -> 
      return rs{f_GetTableRegions_result_io =Just e}))
  writeMessageBegin oprot ("getTableRegions", M_REPLY, seqid);
  write_GetTableRegions_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_createTable (seqid, iprot, oprot, handler) = do
  args <- read_CreateTable_args iprot
  readMessageEnd iprot
  rs <- return (CreateTable_result Nothing Nothing Nothing)
  res <- (Control.Exception.catch
    (Control.Exception.catch
      (Control.Exception.catch
        (do
          Iface.createTable handler (f_CreateTable_args_tableName args) (f_CreateTable_args_columnFamilies args)
          return rs)
        (\e  -> 
          return rs{f_CreateTable_result_io =Just e}))
      (\e  -> 
        return rs{f_CreateTable_result_ia =Just e}))
    (\e  -> 
      return rs{f_CreateTable_result_exist =Just e}))
  writeMessageBegin oprot ("createTable", M_REPLY, seqid);
  write_CreateTable_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_deleteTable (seqid, iprot, oprot, handler) = do
  args <- read_DeleteTable_args iprot
  readMessageEnd iprot
  rs <- return (DeleteTable_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.deleteTable handler (f_DeleteTable_args_tableName args)
      return rs)
    (\e  -> 
      return rs{f_DeleteTable_result_io =Just e}))
  writeMessageBegin oprot ("deleteTable", M_REPLY, seqid);
  write_DeleteTable_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_get (seqid, iprot, oprot, handler) = do
  args <- read_Get_args iprot
  readMessageEnd iprot
  rs <- return (Get_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.get handler (f_Get_args_tableName args) (f_Get_args_row args) (f_Get_args_column args) (f_Get_args_attributes args)
      return rs{f_Get_result_success= Just res})
    (\e  -> 
      return rs{f_Get_result_io =Just e}))
  writeMessageBegin oprot ("get", M_REPLY, seqid);
  write_Get_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getVer (seqid, iprot, oprot, handler) = do
  args <- read_GetVer_args iprot
  readMessageEnd iprot
  rs <- return (GetVer_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getVer handler (f_GetVer_args_tableName args) (f_GetVer_args_row args) (f_GetVer_args_column args) (f_GetVer_args_numVersions args) (f_GetVer_args_attributes args)
      return rs{f_GetVer_result_success= Just res})
    (\e  -> 
      return rs{f_GetVer_result_io =Just e}))
  writeMessageBegin oprot ("getVer", M_REPLY, seqid);
  write_GetVer_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getVerTs (seqid, iprot, oprot, handler) = do
  args <- read_GetVerTs_args iprot
  readMessageEnd iprot
  rs <- return (GetVerTs_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getVerTs handler (f_GetVerTs_args_tableName args) (f_GetVerTs_args_row args) (f_GetVerTs_args_column args) (f_GetVerTs_args_timestamp args) (f_GetVerTs_args_numVersions args) (f_GetVerTs_args_attributes args)
      return rs{f_GetVerTs_result_success= Just res})
    (\e  -> 
      return rs{f_GetVerTs_result_io =Just e}))
  writeMessageBegin oprot ("getVerTs", M_REPLY, seqid);
  write_GetVerTs_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getRow (seqid, iprot, oprot, handler) = do
  args <- read_GetRow_args iprot
  readMessageEnd iprot
  rs <- return (GetRow_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getRow handler (f_GetRow_args_tableName args) (f_GetRow_args_row args) (f_GetRow_args_attributes args)
      return rs{f_GetRow_result_success= Just res})
    (\e  -> 
      return rs{f_GetRow_result_io =Just e}))
  writeMessageBegin oprot ("getRow", M_REPLY, seqid);
  write_GetRow_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getRowWithColumns (seqid, iprot, oprot, handler) = do
  args <- read_GetRowWithColumns_args iprot
  readMessageEnd iprot
  rs <- return (GetRowWithColumns_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getRowWithColumns handler (f_GetRowWithColumns_args_tableName args) (f_GetRowWithColumns_args_row args) (f_GetRowWithColumns_args_columns args) (f_GetRowWithColumns_args_attributes args)
      return rs{f_GetRowWithColumns_result_success= Just res})
    (\e  -> 
      return rs{f_GetRowWithColumns_result_io =Just e}))
  writeMessageBegin oprot ("getRowWithColumns", M_REPLY, seqid);
  write_GetRowWithColumns_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getRowTs (seqid, iprot, oprot, handler) = do
  args <- read_GetRowTs_args iprot
  readMessageEnd iprot
  rs <- return (GetRowTs_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getRowTs handler (f_GetRowTs_args_tableName args) (f_GetRowTs_args_row args) (f_GetRowTs_args_timestamp args) (f_GetRowTs_args_attributes args)
      return rs{f_GetRowTs_result_success= Just res})
    (\e  -> 
      return rs{f_GetRowTs_result_io =Just e}))
  writeMessageBegin oprot ("getRowTs", M_REPLY, seqid);
  write_GetRowTs_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getRowWithColumnsTs (seqid, iprot, oprot, handler) = do
  args <- read_GetRowWithColumnsTs_args iprot
  readMessageEnd iprot
  rs <- return (GetRowWithColumnsTs_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getRowWithColumnsTs handler (f_GetRowWithColumnsTs_args_tableName args) (f_GetRowWithColumnsTs_args_row args) (f_GetRowWithColumnsTs_args_columns args) (f_GetRowWithColumnsTs_args_timestamp args) (f_GetRowWithColumnsTs_args_attributes args)
      return rs{f_GetRowWithColumnsTs_result_success= Just res})
    (\e  -> 
      return rs{f_GetRowWithColumnsTs_result_io =Just e}))
  writeMessageBegin oprot ("getRowWithColumnsTs", M_REPLY, seqid);
  write_GetRowWithColumnsTs_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getRows (seqid, iprot, oprot, handler) = do
  args <- read_GetRows_args iprot
  readMessageEnd iprot
  rs <- return (GetRows_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getRows handler (f_GetRows_args_tableName args) (f_GetRows_args_rows args) (f_GetRows_args_attributes args)
      return rs{f_GetRows_result_success= Just res})
    (\e  -> 
      return rs{f_GetRows_result_io =Just e}))
  writeMessageBegin oprot ("getRows", M_REPLY, seqid);
  write_GetRows_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getRowsWithColumns (seqid, iprot, oprot, handler) = do
  args <- read_GetRowsWithColumns_args iprot
  readMessageEnd iprot
  rs <- return (GetRowsWithColumns_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getRowsWithColumns handler (f_GetRowsWithColumns_args_tableName args) (f_GetRowsWithColumns_args_rows args) (f_GetRowsWithColumns_args_columns args) (f_GetRowsWithColumns_args_attributes args)
      return rs{f_GetRowsWithColumns_result_success= Just res})
    (\e  -> 
      return rs{f_GetRowsWithColumns_result_io =Just e}))
  writeMessageBegin oprot ("getRowsWithColumns", M_REPLY, seqid);
  write_GetRowsWithColumns_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getRowsTs (seqid, iprot, oprot, handler) = do
  args <- read_GetRowsTs_args iprot
  readMessageEnd iprot
  rs <- return (GetRowsTs_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getRowsTs handler (f_GetRowsTs_args_tableName args) (f_GetRowsTs_args_rows args) (f_GetRowsTs_args_timestamp args) (f_GetRowsTs_args_attributes args)
      return rs{f_GetRowsTs_result_success= Just res})
    (\e  -> 
      return rs{f_GetRowsTs_result_io =Just e}))
  writeMessageBegin oprot ("getRowsTs", M_REPLY, seqid);
  write_GetRowsTs_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getRowsWithColumnsTs (seqid, iprot, oprot, handler) = do
  args <- read_GetRowsWithColumnsTs_args iprot
  readMessageEnd iprot
  rs <- return (GetRowsWithColumnsTs_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getRowsWithColumnsTs handler (f_GetRowsWithColumnsTs_args_tableName args) (f_GetRowsWithColumnsTs_args_rows args) (f_GetRowsWithColumnsTs_args_columns args) (f_GetRowsWithColumnsTs_args_timestamp args) (f_GetRowsWithColumnsTs_args_attributes args)
      return rs{f_GetRowsWithColumnsTs_result_success= Just res})
    (\e  -> 
      return rs{f_GetRowsWithColumnsTs_result_io =Just e}))
  writeMessageBegin oprot ("getRowsWithColumnsTs", M_REPLY, seqid);
  write_GetRowsWithColumnsTs_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_mutateRow (seqid, iprot, oprot, handler) = do
  args <- read_MutateRow_args iprot
  readMessageEnd iprot
  rs <- return (MutateRow_result Nothing Nothing)
  res <- (Control.Exception.catch
    (Control.Exception.catch
      (do
        Iface.mutateRow handler (f_MutateRow_args_tableName args) (f_MutateRow_args_row args) (f_MutateRow_args_mutations args) (f_MutateRow_args_attributes args)
        return rs)
      (\e  -> 
        return rs{f_MutateRow_result_io =Just e}))
    (\e  -> 
      return rs{f_MutateRow_result_ia =Just e}))
  writeMessageBegin oprot ("mutateRow", M_REPLY, seqid);
  write_MutateRow_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_mutateRowTs (seqid, iprot, oprot, handler) = do
  args <- read_MutateRowTs_args iprot
  readMessageEnd iprot
  rs <- return (MutateRowTs_result Nothing Nothing)
  res <- (Control.Exception.catch
    (Control.Exception.catch
      (do
        Iface.mutateRowTs handler (f_MutateRowTs_args_tableName args) (f_MutateRowTs_args_row args) (f_MutateRowTs_args_mutations args) (f_MutateRowTs_args_timestamp args) (f_MutateRowTs_args_attributes args)
        return rs)
      (\e  -> 
        return rs{f_MutateRowTs_result_io =Just e}))
    (\e  -> 
      return rs{f_MutateRowTs_result_ia =Just e}))
  writeMessageBegin oprot ("mutateRowTs", M_REPLY, seqid);
  write_MutateRowTs_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_mutateRows (seqid, iprot, oprot, handler) = do
  args <- read_MutateRows_args iprot
  readMessageEnd iprot
  rs <- return (MutateRows_result Nothing Nothing)
  res <- (Control.Exception.catch
    (Control.Exception.catch
      (do
        Iface.mutateRows handler (f_MutateRows_args_tableName args) (f_MutateRows_args_rowBatches args) (f_MutateRows_args_attributes args)
        return rs)
      (\e  -> 
        return rs{f_MutateRows_result_io =Just e}))
    (\e  -> 
      return rs{f_MutateRows_result_ia =Just e}))
  writeMessageBegin oprot ("mutateRows", M_REPLY, seqid);
  write_MutateRows_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_mutateRowsTs (seqid, iprot, oprot, handler) = do
  args <- read_MutateRowsTs_args iprot
  readMessageEnd iprot
  rs <- return (MutateRowsTs_result Nothing Nothing)
  res <- (Control.Exception.catch
    (Control.Exception.catch
      (do
        Iface.mutateRowsTs handler (f_MutateRowsTs_args_tableName args) (f_MutateRowsTs_args_rowBatches args) (f_MutateRowsTs_args_timestamp args) (f_MutateRowsTs_args_attributes args)
        return rs)
      (\e  -> 
        return rs{f_MutateRowsTs_result_io =Just e}))
    (\e  -> 
      return rs{f_MutateRowsTs_result_ia =Just e}))
  writeMessageBegin oprot ("mutateRowsTs", M_REPLY, seqid);
  write_MutateRowsTs_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_atomicIncrement (seqid, iprot, oprot, handler) = do
  args <- read_AtomicIncrement_args iprot
  readMessageEnd iprot
  rs <- return (AtomicIncrement_result Nothing Nothing Nothing)
  res <- (Control.Exception.catch
    (Control.Exception.catch
      (do
        res <- Iface.atomicIncrement handler (f_AtomicIncrement_args_tableName args) (f_AtomicIncrement_args_row args) (f_AtomicIncrement_args_column args) (f_AtomicIncrement_args_value args)
        return rs{f_AtomicIncrement_result_success= Just res})
      (\e  -> 
        return rs{f_AtomicIncrement_result_io =Just e}))
    (\e  -> 
      return rs{f_AtomicIncrement_result_ia =Just e}))
  writeMessageBegin oprot ("atomicIncrement", M_REPLY, seqid);
  write_AtomicIncrement_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_deleteAll (seqid, iprot, oprot, handler) = do
  args <- read_DeleteAll_args iprot
  readMessageEnd iprot
  rs <- return (DeleteAll_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.deleteAll handler (f_DeleteAll_args_tableName args) (f_DeleteAll_args_row args) (f_DeleteAll_args_column args) (f_DeleteAll_args_attributes args)
      return rs)
    (\e  -> 
      return rs{f_DeleteAll_result_io =Just e}))
  writeMessageBegin oprot ("deleteAll", M_REPLY, seqid);
  write_DeleteAll_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_deleteAllTs (seqid, iprot, oprot, handler) = do
  args <- read_DeleteAllTs_args iprot
  readMessageEnd iprot
  rs <- return (DeleteAllTs_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.deleteAllTs handler (f_DeleteAllTs_args_tableName args) (f_DeleteAllTs_args_row args) (f_DeleteAllTs_args_column args) (f_DeleteAllTs_args_timestamp args) (f_DeleteAllTs_args_attributes args)
      return rs)
    (\e  -> 
      return rs{f_DeleteAllTs_result_io =Just e}))
  writeMessageBegin oprot ("deleteAllTs", M_REPLY, seqid);
  write_DeleteAllTs_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_deleteAllRow (seqid, iprot, oprot, handler) = do
  args <- read_DeleteAllRow_args iprot
  readMessageEnd iprot
  rs <- return (DeleteAllRow_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.deleteAllRow handler (f_DeleteAllRow_args_tableName args) (f_DeleteAllRow_args_row args) (f_DeleteAllRow_args_attributes args)
      return rs)
    (\e  -> 
      return rs{f_DeleteAllRow_result_io =Just e}))
  writeMessageBegin oprot ("deleteAllRow", M_REPLY, seqid);
  write_DeleteAllRow_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_increment (seqid, iprot, oprot, handler) = do
  args <- read_Increment_args iprot
  readMessageEnd iprot
  rs <- return (Increment_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.increment handler (f_Increment_args_increment args)
      return rs)
    (\e  -> 
      return rs{f_Increment_result_io =Just e}))
  writeMessageBegin oprot ("increment", M_REPLY, seqid);
  write_Increment_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_incrementRows (seqid, iprot, oprot, handler) = do
  args <- read_IncrementRows_args iprot
  readMessageEnd iprot
  rs <- return (IncrementRows_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.incrementRows handler (f_IncrementRows_args_increments args)
      return rs)
    (\e  -> 
      return rs{f_IncrementRows_result_io =Just e}))
  writeMessageBegin oprot ("incrementRows", M_REPLY, seqid);
  write_IncrementRows_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_deleteAllRowTs (seqid, iprot, oprot, handler) = do
  args <- read_DeleteAllRowTs_args iprot
  readMessageEnd iprot
  rs <- return (DeleteAllRowTs_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.deleteAllRowTs handler (f_DeleteAllRowTs_args_tableName args) (f_DeleteAllRowTs_args_row args) (f_DeleteAllRowTs_args_timestamp args) (f_DeleteAllRowTs_args_attributes args)
      return rs)
    (\e  -> 
      return rs{f_DeleteAllRowTs_result_io =Just e}))
  writeMessageBegin oprot ("deleteAllRowTs", M_REPLY, seqid);
  write_DeleteAllRowTs_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_scannerOpenWithScan (seqid, iprot, oprot, handler) = do
  args <- read_ScannerOpenWithScan_args iprot
  readMessageEnd iprot
  rs <- return (ScannerOpenWithScan_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.scannerOpenWithScan handler (f_ScannerOpenWithScan_args_tableName args) (f_ScannerOpenWithScan_args_scan args) (f_ScannerOpenWithScan_args_attributes args)
      return rs{f_ScannerOpenWithScan_result_success= Just res})
    (\e  -> 
      return rs{f_ScannerOpenWithScan_result_io =Just e}))
  writeMessageBegin oprot ("scannerOpenWithScan", M_REPLY, seqid);
  write_ScannerOpenWithScan_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_scannerOpen (seqid, iprot, oprot, handler) = do
  args <- read_ScannerOpen_args iprot
  readMessageEnd iprot
  rs <- return (ScannerOpen_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.scannerOpen handler (f_ScannerOpen_args_tableName args) (f_ScannerOpen_args_startRow args) (f_ScannerOpen_args_columns args) (f_ScannerOpen_args_attributes args)
      return rs{f_ScannerOpen_result_success= Just res})
    (\e  -> 
      return rs{f_ScannerOpen_result_io =Just e}))
  writeMessageBegin oprot ("scannerOpen", M_REPLY, seqid);
  write_ScannerOpen_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_scannerOpenWithStop (seqid, iprot, oprot, handler) = do
  args <- read_ScannerOpenWithStop_args iprot
  readMessageEnd iprot
  rs <- return (ScannerOpenWithStop_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.scannerOpenWithStop handler (f_ScannerOpenWithStop_args_tableName args) (f_ScannerOpenWithStop_args_startRow args) (f_ScannerOpenWithStop_args_stopRow args) (f_ScannerOpenWithStop_args_columns args) (f_ScannerOpenWithStop_args_attributes args)
      return rs{f_ScannerOpenWithStop_result_success= Just res})
    (\e  -> 
      return rs{f_ScannerOpenWithStop_result_io =Just e}))
  writeMessageBegin oprot ("scannerOpenWithStop", M_REPLY, seqid);
  write_ScannerOpenWithStop_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_scannerOpenWithPrefix (seqid, iprot, oprot, handler) = do
  args <- read_ScannerOpenWithPrefix_args iprot
  readMessageEnd iprot
  rs <- return (ScannerOpenWithPrefix_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.scannerOpenWithPrefix handler (f_ScannerOpenWithPrefix_args_tableName args) (f_ScannerOpenWithPrefix_args_startAndPrefix args) (f_ScannerOpenWithPrefix_args_columns args) (f_ScannerOpenWithPrefix_args_attributes args)
      return rs{f_ScannerOpenWithPrefix_result_success= Just res})
    (\e  -> 
      return rs{f_ScannerOpenWithPrefix_result_io =Just e}))
  writeMessageBegin oprot ("scannerOpenWithPrefix", M_REPLY, seqid);
  write_ScannerOpenWithPrefix_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_scannerOpenTs (seqid, iprot, oprot, handler) = do
  args <- read_ScannerOpenTs_args iprot
  readMessageEnd iprot
  rs <- return (ScannerOpenTs_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.scannerOpenTs handler (f_ScannerOpenTs_args_tableName args) (f_ScannerOpenTs_args_startRow args) (f_ScannerOpenTs_args_columns args) (f_ScannerOpenTs_args_timestamp args) (f_ScannerOpenTs_args_attributes args)
      return rs{f_ScannerOpenTs_result_success= Just res})
    (\e  -> 
      return rs{f_ScannerOpenTs_result_io =Just e}))
  writeMessageBegin oprot ("scannerOpenTs", M_REPLY, seqid);
  write_ScannerOpenTs_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_scannerOpenWithStopTs (seqid, iprot, oprot, handler) = do
  args <- read_ScannerOpenWithStopTs_args iprot
  readMessageEnd iprot
  rs <- return (ScannerOpenWithStopTs_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.scannerOpenWithStopTs handler (f_ScannerOpenWithStopTs_args_tableName args) (f_ScannerOpenWithStopTs_args_startRow args) (f_ScannerOpenWithStopTs_args_stopRow args) (f_ScannerOpenWithStopTs_args_columns args) (f_ScannerOpenWithStopTs_args_timestamp args) (f_ScannerOpenWithStopTs_args_attributes args)
      return rs{f_ScannerOpenWithStopTs_result_success= Just res})
    (\e  -> 
      return rs{f_ScannerOpenWithStopTs_result_io =Just e}))
  writeMessageBegin oprot ("scannerOpenWithStopTs", M_REPLY, seqid);
  write_ScannerOpenWithStopTs_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_scannerGet (seqid, iprot, oprot, handler) = do
  args <- read_ScannerGet_args iprot
  readMessageEnd iprot
  rs <- return (ScannerGet_result Nothing Nothing Nothing)
  res <- (Control.Exception.catch
    (Control.Exception.catch
      (do
        res <- Iface.scannerGet handler (f_ScannerGet_args_id args)
        return rs{f_ScannerGet_result_success= Just res})
      (\e  -> 
        return rs{f_ScannerGet_result_io =Just e}))
    (\e  -> 
      return rs{f_ScannerGet_result_ia =Just e}))
  writeMessageBegin oprot ("scannerGet", M_REPLY, seqid);
  write_ScannerGet_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_scannerGetList (seqid, iprot, oprot, handler) = do
  args <- read_ScannerGetList_args iprot
  readMessageEnd iprot
  rs <- return (ScannerGetList_result Nothing Nothing Nothing)
  res <- (Control.Exception.catch
    (Control.Exception.catch
      (do
        res <- Iface.scannerGetList handler (f_ScannerGetList_args_id args) (f_ScannerGetList_args_nbRows args)
        return rs{f_ScannerGetList_result_success= Just res})
      (\e  -> 
        return rs{f_ScannerGetList_result_io =Just e}))
    (\e  -> 
      return rs{f_ScannerGetList_result_ia =Just e}))
  writeMessageBegin oprot ("scannerGetList", M_REPLY, seqid);
  write_ScannerGetList_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_scannerClose (seqid, iprot, oprot, handler) = do
  args <- read_ScannerClose_args iprot
  readMessageEnd iprot
  rs <- return (ScannerClose_result Nothing Nothing)
  res <- (Control.Exception.catch
    (Control.Exception.catch
      (do
        Iface.scannerClose handler (f_ScannerClose_args_id args)
        return rs)
      (\e  -> 
        return rs{f_ScannerClose_result_io =Just e}))
    (\e  -> 
      return rs{f_ScannerClose_result_ia =Just e}))
  writeMessageBegin oprot ("scannerClose", M_REPLY, seqid);
  write_ScannerClose_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getRowOrBefore (seqid, iprot, oprot, handler) = do
  args <- read_GetRowOrBefore_args iprot
  readMessageEnd iprot
  rs <- return (GetRowOrBefore_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getRowOrBefore handler (f_GetRowOrBefore_args_tableName args) (f_GetRowOrBefore_args_row args) (f_GetRowOrBefore_args_family args)
      return rs{f_GetRowOrBefore_result_success= Just res})
    (\e  -> 
      return rs{f_GetRowOrBefore_result_io =Just e}))
  writeMessageBegin oprot ("getRowOrBefore", M_REPLY, seqid);
  write_GetRowOrBefore_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_getRegionInfo (seqid, iprot, oprot, handler) = do
  args <- read_GetRegionInfo_args iprot
  readMessageEnd iprot
  rs <- return (GetRegionInfo_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.getRegionInfo handler (f_GetRegionInfo_args_row args)
      return rs{f_GetRegionInfo_result_success= Just res})
    (\e  -> 
      return rs{f_GetRegionInfo_result_io =Just e}))
  writeMessageBegin oprot ("getRegionInfo", M_REPLY, seqid);
  write_GetRegionInfo_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "enableTable" -> process_enableTable (seqid,iprot,oprot,handler)
  "disableTable" -> process_disableTable (seqid,iprot,oprot,handler)
  "isTableEnabled" -> process_isTableEnabled (seqid,iprot,oprot,handler)
  "compact" -> process_compact (seqid,iprot,oprot,handler)
  "majorCompact" -> process_majorCompact (seqid,iprot,oprot,handler)
  "getTableNames" -> process_getTableNames (seqid,iprot,oprot,handler)
  "getColumnDescriptors" -> process_getColumnDescriptors (seqid,iprot,oprot,handler)
  "getTableRegions" -> process_getTableRegions (seqid,iprot,oprot,handler)
  "createTable" -> process_createTable (seqid,iprot,oprot,handler)
  "deleteTable" -> process_deleteTable (seqid,iprot,oprot,handler)
  "get" -> process_get (seqid,iprot,oprot,handler)
  "getVer" -> process_getVer (seqid,iprot,oprot,handler)
  "getVerTs" -> process_getVerTs (seqid,iprot,oprot,handler)
  "getRow" -> process_getRow (seqid,iprot,oprot,handler)
  "getRowWithColumns" -> process_getRowWithColumns (seqid,iprot,oprot,handler)
  "getRowTs" -> process_getRowTs (seqid,iprot,oprot,handler)
  "getRowWithColumnsTs" -> process_getRowWithColumnsTs (seqid,iprot,oprot,handler)
  "getRows" -> process_getRows (seqid,iprot,oprot,handler)
  "getRowsWithColumns" -> process_getRowsWithColumns (seqid,iprot,oprot,handler)
  "getRowsTs" -> process_getRowsTs (seqid,iprot,oprot,handler)
  "getRowsWithColumnsTs" -> process_getRowsWithColumnsTs (seqid,iprot,oprot,handler)
  "mutateRow" -> process_mutateRow (seqid,iprot,oprot,handler)
  "mutateRowTs" -> process_mutateRowTs (seqid,iprot,oprot,handler)
  "mutateRows" -> process_mutateRows (seqid,iprot,oprot,handler)
  "mutateRowsTs" -> process_mutateRowsTs (seqid,iprot,oprot,handler)
  "atomicIncrement" -> process_atomicIncrement (seqid,iprot,oprot,handler)
  "deleteAll" -> process_deleteAll (seqid,iprot,oprot,handler)
  "deleteAllTs" -> process_deleteAllTs (seqid,iprot,oprot,handler)
  "deleteAllRow" -> process_deleteAllRow (seqid,iprot,oprot,handler)
  "increment" -> process_increment (seqid,iprot,oprot,handler)
  "incrementRows" -> process_incrementRows (seqid,iprot,oprot,handler)
  "deleteAllRowTs" -> process_deleteAllRowTs (seqid,iprot,oprot,handler)
  "scannerOpenWithScan" -> process_scannerOpenWithScan (seqid,iprot,oprot,handler)
  "scannerOpen" -> process_scannerOpen (seqid,iprot,oprot,handler)
  "scannerOpenWithStop" -> process_scannerOpenWithStop (seqid,iprot,oprot,handler)
  "scannerOpenWithPrefix" -> process_scannerOpenWithPrefix (seqid,iprot,oprot,handler)
  "scannerOpenTs" -> process_scannerOpenTs (seqid,iprot,oprot,handler)
  "scannerOpenWithStopTs" -> process_scannerOpenWithStopTs (seqid,iprot,oprot,handler)
  "scannerGet" -> process_scannerGet (seqid,iprot,oprot,handler)
  "scannerGetList" -> process_scannerGetList (seqid,iprot,oprot,handler)
  "scannerClose" -> process_scannerClose (seqid,iprot,oprot,handler)
  "getRowOrBefore" -> process_getRowOrBefore (seqid,iprot,oprot,handler)
  "getRegionInfo" -> process_getRegionInfo (seqid,iprot,oprot,handler)
  _ -> do
    skip iprot T_STRUCT
    readMessageEnd iprot
    writeMessageBegin oprot (name,M_EXCEPTION,seqid)
    writeAppExn oprot (AppExn AE_UNKNOWN_METHOD ("Unknown function " ++ TL.unpack name))
    writeMessageEnd oprot
    tFlush (getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  return True
